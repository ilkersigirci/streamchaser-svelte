
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, a as append_styles, m as create_slot, b as validate_slots, e as element, f as space, g as attr_dev, h as add_location, o as toggle_class, j as insert_dev, k as append_dev, p as action_destroyer, q as update_slot_base, r as get_all_dirty_from_scope, w as get_slot_changes, x as is_function, y as transition_in, z as transition_out, l as detach_dev, I as compute_rest_props, H as assign, J as exclude_internal_props, W as validate_each_argument, A as create_component, B as mount_component, C as destroy_component, O as bubble, P as binding_callbacks, D as set_style, L as listen_dev, n as noop, K as set_attributes, a3 as set_input_value, M as get_spread_update, Q as group_outros, R as check_outros, N as run_all, t as text, G as set_data_dev, Z as destroy_each, a4 as validate_each_keys, a5 as onMount, a6 as tick, a7 as set_custom_element_data, X as add_render_callback, a8 as add_resize_listener, a9 as update_keyed_each, aa as outro_and_destroy_block, _ as createEventDispatcher, ab as onDestroy, ac as beforeUpdate, ad as empty, F as svg_element, ae as globals, af as get_spread_object, ag as prevent_default, ah as HtmlTag, v as validate_store, c as component_subscribe, T as currentCountry, U as goto, ai as bind, a2 as create_bidirectional_transition, aj as add_flush_callback, ak as handle_promise, al as update_await_block_branch, E as src_url_equal } from './main.js';
import { f as fly } from './index.js';
import { u as uid, I as Icon, C as Class, M as MaterialApp, H as Header } from './Header.js';
import { C as Card } from './Card.js';

/* eslint-disable no-param-reassign */

/**
 * @param {string} klass
 */
function formatClass(klass) {
  return klass.split(' ').map((i) => {
    if (/^(lighten|darken|accent)-/.test(i)) {
      return `text-${i}`;
    }
    return `${i}-text`;
  });
}

function setTextColor(node, text) {
  if (/^(#|rgb|hsl|currentColor)/.test(text)) {
    // This is a CSS hex.
    node.style.color = text;
    return false;
  }
  if (text.startsWith('--')) {
    // This is a CSS variable.
    node.style.color = `var(${text})`;
    return false;
  }
  const klass = formatClass(text);
  node.classList.add(...klass);
  return klass;
}

/**
 * @param node {Element}
 * @param text {string|boolean}
 */
var TextColor = (node, text) => {
  let klass;
  if (typeof text === 'string') {
    klass = setTextColor(node, text);
  }

  return {
    update(newText) {
      if (klass) {
        node.classList.remove(...klass);
      } else {
        node.style.color = null;
      }

      if (typeof newText === 'string') {
        klass = setTextColor(node, newText);
      }
    },
  };
};

/* node_modules/svelte-materialify/dist/components/Input/Input.svelte generated by Svelte v3.42.1 */
const file$b = "node_modules/svelte-materialify/dist/components/Input/Input.svelte";

function add_css$9(target) {
	append_styles(target, "svelte-it3jql", ".s-text-field__input{display:flex;flex-grow:1}.s-text-field__input label{position:absolute;max-width:90%;overflow:hidden;text-overflow:ellipsis;top:6px;pointer-events:none;transform-origin:top left}.s-text-field__input label.active{max-width:133%;transform:translateY(-18px) scale(0.75)}.s-text-field__input input{caret-color:inherit;flex:1 1 auto;line-height:20px;padding:8px 0;max-width:100%;min-width:0;width:100%}.s-text-field__wrapper{width:100%;color:inherit;caret-color:currentColor;display:flex;align-items:center}.s-text-field__wrapper:after,.s-text-field__wrapper:before{border-radius:inherit;width:inherit;bottom:-1px;content:\"\";left:0;position:absolute;transition:0.3s cubic-bezier(0.25, 0.8, 0.5, 1);pointer-events:none}.s-text-field__wrapper:before{border:solid var(--theme-text-fields-border);border-width:thin 0 0}.s-text-field__wrapper:after{background-color:currentColor;border-color:currentcolor;border-style:solid;border-width:thin 0;transform:scaleX(0)}.s-text-field__wrapper:hover:before{border-color:var(--theme-text-primary)}.s-text-field__wrapper:focus-within:after{transform:scale(1)}.s-text-field__wrapper:focus-within label{color:inherit}.s-text-field__wrapper>[slot=append],.s-text-field__wrapper>[slot=prepend]{margin-right:8px}.s-text-field__wrapper.outlined:before{top:0;border-width:thin}.s-text-field__wrapper.outlined:focus-within:before{border-color:currentColor;border-width:2px}.s-text-field__wrapper.outlined label{top:18px}.s-text-field__wrapper.outlined label.active{padding:0 4px;background-color:var(--theme-surface);transform:translateY(-24px) scale(0.75)}.s-text-field__wrapper.filled,.s-text-field__wrapper.outlined,.s-text-field__wrapper.solo{padding:0 1px 0 12px}.s-text-field__wrapper.filled,.s-text-field__wrapper.outlined{min-height:56px}.s-text-field__wrapper.filled{border-radius:4px 4px 0 0;background-color:var(--theme-text-fields-filled)}.s-text-field__wrapper.filled:hover{background-color:var(--theme-text-fields-filled-hover)}.s-text-field__wrapper.filled input,.s-text-field__wrapper.filled textarea{padding-top:22px}.s-text-field__wrapper.filled label{top:20px}.s-text-field__wrapper.filled label.active{transform:translateY(-10px) scale(0.75)}.s-text-field__wrapper.outlined:after,.s-text-field__wrapper.rounded:after,.s-text-field__wrapper.solo:after{display:none}.s-text-field__wrapper.outlined,.s-text-field__wrapper.solo{border-radius:4px}.s-text-field__wrapper.solo{min-height:48px;box-shadow:0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)}.s-text-field__wrapper.solo:before{display:none}.s-text-field__wrapper.rounded{border-radius:28px}.s-text-field__wrapper.rounded.filled:before{border:none}.s-text-field__wrapper.rounded.outlined{padding:0 24px}.s-text-field__wrapper.flat{box-shadow:0 0 0 0 rgba(0, 0, 0, 0.2), 0 0 0 0 rgba(0, 0, 0, 0.14), 0 0 0 0 rgba(0, 0, 0, 0.12) !important}.s-text-field.error .s-text-field__wrapper:before,.s-text-field.success .s-text-field__wrapper:before{border-color:currentColor !important}.s-text-field.dense input{padding:4px 0 2px}.s-text-field.dense .s-text-field__wrapper.filled,.s-text-field.dense .s-text-field__wrapper.outlined{min-height:40px}.s-text-field.dense .s-text-field__wrapper.outlined label{top:10px}.s-text-field.dense .s-text-field__wrapper.outlined label.active{transform:translateY(-16px) scale(0.75)}.s-text-field.dense .s-text-field__wrapper.solo{min-height:40px}.s-text-field.dense .s-text-field__wrapper.filled input,.s-text-field.dense .s-text-field__wrapper.filled textarea{margin-top:11px}.s-text-field.dense .s-text-field__wrapper.filled label{top:12px}.s-text-field.dense .s-text-field__wrapper.filled label.active{transform:translateY(-8px) scale(0.75)}.s-textarea textarea{align-self:stretch;flex:1 1 auto;line-height:1.75rem;max-width:100%;min-height:32px;outline:none;padding:0;width:100%;margin-top:4px}.s-textarea .s-text-field__wrapper>[slot=append],.s-textarea .s-text-field__wrapper>[slot=prepend]{align-self:flex-start;margin-top:2px}.s-textarea .s-text-field__wrapper.filled [slot=append],.s-textarea .s-text-field__wrapper.filled [slot=prepend]{margin-top:28px}.s-textarea .s-text-field__wrapper.outlined [slot=append],.s-textarea .s-text-field__wrapper.outlined [slot=prepend]{margin-top:20px}.s-textarea .s-text-field__wrapper.outlined textarea{margin-top:18px}.s-textarea .s-text-field__wrapper.solo [slot=append],.s-textarea .s-text-field__wrapper.solo [slot=prepend],.s-textarea .s-text-field__wrapper.solo textarea{margin-top:8px}.s-textarea .s-text-field__wrapper.autogrow textarea{overflow:hidden}.s-textarea .s-text-field__wrapper.no-resize textarea{resize:none}.s-input__slot{border-radius:inherit;align-items:center;color:inherit;display:flex;margin-bottom:8px;position:relative;transition:0.3s cubic-bezier(0.25, 0.8, 0.5, 1);width:100%;height:inherit}.s-input__control{display:flex;flex-direction:column;width:100%}.s-input__details{color:var(--theme-text-secondary);display:flex;flex:1 0 auto;max-width:100%;font-size:12px;overflow:hidden}.s-input__details>[slot=messages]{display:flex;flex-direction:row;justify-content:space-between;flex-grow:1}.s-input{display:flex;align-items:center;flex-direction:row;flex:1 1 auto;font-size:16px;letter-spacing:normal;max-width:100%;text-align:left}.s-input input{max-height:32px}.s-input input,.s-input textarea{color:var(--theme-text-primary)}.s-input input:invalid,.s-input textarea:invalid{box-shadow:none}.s-input input:active,.s-input input:focus,.s-input textarea:active,.s-input textarea:focus{outline:none}.s-input input::placeholder,.s-input textarea::placeholder{color:var(--theme-text-disabled)}.s-input>[slot=append-outer],.s-input>[slot=prepend-outer]{align-self:flex-start;display:inline-flex;margin-bottom:4px;margin-top:4px;line-height:1}.s-input>[slot=prepend-outer]{margin-right:9px}.s-input>[slot=append-outer]{margin-left:9px}.s-input .s-icon{user-select:none;align-items:center;display:inline-flex;height:24px;flex:1 0 auto;justify-content:center;min-width:24px;width:24px}.s-input label{height:20px;line-height:20px;color:var(--theme-text-secondary);white-space:nowrap;transition:0.3s cubic-bezier(0.25, 0.8, 0.5, 1)}.s-input:focus-within .s-icon{color:inherit}.s-input.disabled{pointer-events:none}.s-input.disabled,.s-input.disabled input,.s-input.disabled textarea{color:var(--theme-text-disabled)}.s-input.disabled .s-icon{color:var(--theme-icons-inactive)}.s-input.disabled label{color:var(--theme-text-disabled)}.s-input.dense .s-input__slot{margin-bottom:4px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW5wdXQuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWN5QixvQkFBQSxBQUFBLENBQUEsdzNNQUFvM1AiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiSW5wdXQuc3ZlbHRlIl19 */");
}

const get_append_outer_slot_changes$1 = dirty => ({});
const get_append_outer_slot_context$1 = ctx => ({});
const get_messages_slot_changes = dirty => ({});
const get_messages_slot_context = ctx => ({});
const get_prepend_outer_slot_changes$1 = dirty => ({});
const get_prepend_outer_slot_context$1 = ctx => ({});

function create_fragment$b(ctx) {
	let div3;
	let t0;
	let div2;
	let div0;
	let t1;
	let div1;
	let t2;
	let div3_class_value;
	let TextColor_action;
	let current;
	let mounted;
	let dispose;
	const prepend_outer_slot_template = /*#slots*/ ctx[9]["prepend-outer"];
	const prepend_outer_slot = create_slot(prepend_outer_slot_template, ctx, /*$$scope*/ ctx[8], get_prepend_outer_slot_context$1);
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
	const messages_slot_template = /*#slots*/ ctx[9].messages;
	const messages_slot = create_slot(messages_slot_template, ctx, /*$$scope*/ ctx[8], get_messages_slot_context);
	const append_outer_slot_template = /*#slots*/ ctx[9]["append-outer"];
	const append_outer_slot = create_slot(append_outer_slot_template, ctx, /*$$scope*/ ctx[8], get_append_outer_slot_context$1);

	const block = {
		c: function create() {
			div3 = element("div");
			if (prepend_outer_slot) prepend_outer_slot.c();
			t0 = space();
			div2 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			t1 = space();
			div1 = element("div");
			if (messages_slot) messages_slot.c();
			t2 = space();
			if (append_outer_slot) append_outer_slot.c();
			attr_dev(div0, "class", "s-input__slot");
			add_location(div0, file$b, 317, 4, 9721);
			attr_dev(div1, "class", "s-input__details");
			add_location(div1, file$b, 320, 4, 9779);
			attr_dev(div2, "class", "s-input__control");
			add_location(div2, file$b, 316, 2, 9686);
			attr_dev(div3, "class", div3_class_value = "s-input " + /*klass*/ ctx[0]);
			attr_dev(div3, "style", /*style*/ ctx[7]);
			toggle_class(div3, "dense", /*dense*/ ctx[2]);
			toggle_class(div3, "error", /*error*/ ctx[5]);
			toggle_class(div3, "success", /*success*/ ctx[6]);
			toggle_class(div3, "readonly", /*readonly*/ ctx[3]);
			toggle_class(div3, "disabled", /*disabled*/ ctx[4]);
			add_location(div3, file$b, 306, 0, 9468);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);

			if (prepend_outer_slot) {
				prepend_outer_slot.m(div3, null);
			}

			append_dev(div3, t0);
			append_dev(div3, div2);
			append_dev(div2, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			append_dev(div2, t1);
			append_dev(div2, div1);

			if (messages_slot) {
				messages_slot.m(div1, null);
			}

			append_dev(div3, t2);

			if (append_outer_slot) {
				append_outer_slot.m(div3, null);
			}

			current = true;

			if (!mounted) {
				dispose = action_destroyer(TextColor_action = TextColor.call(null, div3, /*success*/ ctx[6]
				? 'success'
				: /*error*/ ctx[5] ? 'error' : /*color*/ ctx[1]));

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (prepend_outer_slot) {
				if (prepend_outer_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot_base(
						prepend_outer_slot,
						prepend_outer_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: get_slot_changes(prepend_outer_slot_template, /*$$scope*/ ctx[8], dirty, get_prepend_outer_slot_changes$1),
						get_prepend_outer_slot_context$1
					);
				}
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
						null
					);
				}
			}

			if (messages_slot) {
				if (messages_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot_base(
						messages_slot,
						messages_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: get_slot_changes(messages_slot_template, /*$$scope*/ ctx[8], dirty, get_messages_slot_changes),
						get_messages_slot_context
					);
				}
			}

			if (append_outer_slot) {
				if (append_outer_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot_base(
						append_outer_slot,
						append_outer_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: get_slot_changes(append_outer_slot_template, /*$$scope*/ ctx[8], dirty, get_append_outer_slot_changes$1),
						get_append_outer_slot_context$1
					);
				}
			}

			if (!current || dirty & /*klass*/ 1 && div3_class_value !== (div3_class_value = "s-input " + /*klass*/ ctx[0])) {
				attr_dev(div3, "class", div3_class_value);
			}

			if (!current || dirty & /*style*/ 128) {
				attr_dev(div3, "style", /*style*/ ctx[7]);
			}

			if (TextColor_action && is_function(TextColor_action.update) && dirty & /*success, error, color*/ 98) TextColor_action.update.call(null, /*success*/ ctx[6]
			? 'success'
			: /*error*/ ctx[5] ? 'error' : /*color*/ ctx[1]);

			if (dirty & /*klass, dense*/ 5) {
				toggle_class(div3, "dense", /*dense*/ ctx[2]);
			}

			if (dirty & /*klass, error*/ 33) {
				toggle_class(div3, "error", /*error*/ ctx[5]);
			}

			if (dirty & /*klass, success*/ 65) {
				toggle_class(div3, "success", /*success*/ ctx[6]);
			}

			if (dirty & /*klass, readonly*/ 9) {
				toggle_class(div3, "readonly", /*readonly*/ ctx[3]);
			}

			if (dirty & /*klass, disabled*/ 17) {
				toggle_class(div3, "disabled", /*disabled*/ ctx[4]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(prepend_outer_slot, local);
			transition_in(default_slot, local);
			transition_in(messages_slot, local);
			transition_in(append_outer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(prepend_outer_slot, local);
			transition_out(default_slot, local);
			transition_out(messages_slot, local);
			transition_out(append_outer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			if (prepend_outer_slot) prepend_outer_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			if (messages_slot) messages_slot.d(detaching);
			if (append_outer_slot) append_outer_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Input', slots, ['prepend-outer','default','messages','append-outer']);
	let { class: klass = '' } = $$props;
	let { color = null } = $$props;
	let { dense = false } = $$props;
	let { readonly = false } = $$props;
	let { disabled = false } = $$props;
	let { error = false } = $$props;
	let { success = false } = $$props;
	let { style = null } = $$props;
	const writable_props = ['class', 'color', 'dense', 'readonly', 'disabled', 'error', 'success', 'style'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Input> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('class' in $$props) $$invalidate(0, klass = $$props.class);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
		if ('dense' in $$props) $$invalidate(2, dense = $$props.dense);
		if ('readonly' in $$props) $$invalidate(3, readonly = $$props.readonly);
		if ('disabled' in $$props) $$invalidate(4, disabled = $$props.disabled);
		if ('error' in $$props) $$invalidate(5, error = $$props.error);
		if ('success' in $$props) $$invalidate(6, success = $$props.success);
		if ('style' in $$props) $$invalidate(7, style = $$props.style);
		if ('$$scope' in $$props) $$invalidate(8, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		TextColor,
		klass,
		color,
		dense,
		readonly,
		disabled,
		error,
		success,
		style
	});

	$$self.$inject_state = $$props => {
		if ('klass' in $$props) $$invalidate(0, klass = $$props.klass);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
		if ('dense' in $$props) $$invalidate(2, dense = $$props.dense);
		if ('readonly' in $$props) $$invalidate(3, readonly = $$props.readonly);
		if ('disabled' in $$props) $$invalidate(4, disabled = $$props.disabled);
		if ('error' in $$props) $$invalidate(5, error = $$props.error);
		if ('success' in $$props) $$invalidate(6, success = $$props.success);
		if ('style' in $$props) $$invalidate(7, style = $$props.style);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [klass, color, dense, readonly, disabled, error, success, style, $$scope, slots];
}

class Input extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$b,
			create_fragment$b,
			safe_not_equal,
			{
				class: 0,
				color: 1,
				dense: 2,
				readonly: 3,
				disabled: 4,
				error: 5,
				success: 6,
				style: 7
			},
			add_css$9
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Input",
			options,
			id: create_fragment$b.name
		});
	}

	get class() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dense() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dense(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get readonly() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get error() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set error(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get success() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set success(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var closeIcon = 'M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z';

/* node_modules/svelte-materialify/dist/components/TextField/TextField.svelte generated by Svelte v3.42.1 */
const file$a = "node_modules/svelte-materialify/dist/components/TextField/TextField.svelte";
const get_append_slot_changes = dirty => ({});
const get_append_slot_context = ctx => ({});
const get_clear_icon_slot_changes = dirty => ({});
const get_clear_icon_slot_context = ctx => ({});
const get_content_slot_changes = dirty => ({});
const get_content_slot_context = ctx => ({});
const get_prepend_slot_changes = dirty => ({});
const get_prepend_slot_context = ctx => ({});
const get_prepend_outer_slot_changes = dirty => ({});
const get_prepend_outer_slot_context = ctx => ({ slot: "prepend-outer" });

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[44] = list[i];
	return child_ctx;
}

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[44] = list[i];
	return child_ctx;
}

const get_append_outer_slot_changes = dirty => ({});
const get_append_outer_slot_context = ctx => ({ slot: "append-outer" });

// (112:4) {#if clearable && value !== ''}
function create_if_block_1$3(ctx) {
	let div;
	let current;
	let mounted;
	let dispose;
	const clear_icon_slot_template = /*#slots*/ ctx[33]["clear-icon"];
	const clear_icon_slot = create_slot(clear_icon_slot_template, ctx, /*$$scope*/ ctx[43], get_clear_icon_slot_context);
	const clear_icon_slot_or_fallback = clear_icon_slot || fallback_block$1(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (clear_icon_slot_or_fallback) clear_icon_slot_or_fallback.c();
			set_style(div, "cursor", "pointer");
			add_location(div, file$a, 112, 6, 2674);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (clear_icon_slot_or_fallback) {
				clear_icon_slot_or_fallback.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", /*clear*/ ctx[26], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (clear_icon_slot) {
				if (clear_icon_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
					update_slot_base(
						clear_icon_slot,
						clear_icon_slot_template,
						ctx,
						/*$$scope*/ ctx[43],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
						: get_slot_changes(clear_icon_slot_template, /*$$scope*/ ctx[43], dirty, get_clear_icon_slot_changes),
						get_clear_icon_slot_context
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(clear_icon_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(clear_icon_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (clear_icon_slot_or_fallback) clear_icon_slot_or_fallback.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$3.name,
		type: "if",
		source: "(112:4) {#if clearable && value !== ''}",
		ctx
	});

	return block;
}

// (115:32)             
function fallback_block$1(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: { path: closeIcon },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$1.name,
		type: "fallback",
		source: "(115:32)             ",
		ctx
	});

	return block;
}

// (64:0) <Input    class="s-text-field {klass}"    {color}    {dense}    {readonly}    {disabled}    {error}    {success}    {style}>
function create_default_slot$2(ctx) {
	let div1;
	let t0;
	let div0;
	let label;
	let t1;
	let t2;
	let input;
	let t3;
	let t4;
	let current;
	let mounted;
	let dispose;
	const prepend_slot_template = /*#slots*/ ctx[33].prepend;
	const prepend_slot = create_slot(prepend_slot_template, ctx, /*$$scope*/ ctx[43], get_prepend_slot_context);
	const default_slot_template = /*#slots*/ ctx[33].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[43], null);
	const content_slot_template = /*#slots*/ ctx[33].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[43], get_content_slot_context);

	let input_levels = [
		{ type: "text" },
		{ placeholder: /*placeholder*/ ctx[14] },
		{ id: /*id*/ ctx[20] },
		{ readOnly: /*readonly*/ ctx[12] },
		{ disabled: /*disabled*/ ctx[13] },
		/*$$restProps*/ ctx[28]
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	let if_block = /*clearable*/ ctx[11] && /*value*/ ctx[0] !== '' && create_if_block_1$3(ctx);
	const append_slot_template = /*#slots*/ ctx[33].append;
	const append_slot = create_slot(append_slot_template, ctx, /*$$scope*/ ctx[43], get_append_slot_context);

	const block = {
		c: function create() {
			div1 = element("div");
			if (prepend_slot) prepend_slot.c();
			t0 = space();
			div0 = element("div");
			label = element("label");
			if (default_slot) default_slot.c();
			t1 = space();
			if (content_slot) content_slot.c();
			t2 = space();
			input = element("input");
			t3 = space();
			if (if_block) if_block.c();
			t4 = space();
			if (append_slot) append_slot.c();
			attr_dev(label, "for", /*id*/ ctx[20]);
			toggle_class(label, "active", /*labelActive*/ ctx[23]);
			add_location(label, file$a, 85, 6, 2024);
			set_attributes(input, input_data);
			add_location(input, file$a, 90, 6, 2215);
			attr_dev(div0, "class", "s-text-field__input");
			add_location(div0, file$a, 84, 4, 1983);
			attr_dev(div1, "class", "s-text-field__wrapper");
			toggle_class(div1, "filled", /*filled*/ ctx[5]);
			toggle_class(div1, "solo", /*solo*/ ctx[6]);
			toggle_class(div1, "outlined", /*outlined*/ ctx[7]);
			toggle_class(div1, "flat", /*flat*/ ctx[8]);
			toggle_class(div1, "rounded", /*rounded*/ ctx[10]);
			add_location(div1, file$a, 74, 2, 1768);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);

			if (prepend_slot) {
				prepend_slot.m(div1, null);
			}

			append_dev(div1, t0);
			append_dev(div1, div0);
			append_dev(div0, label);

			if (default_slot) {
				default_slot.m(label, null);
			}

			append_dev(div0, t1);

			if (content_slot) {
				content_slot.m(div0, null);
			}

			append_dev(div0, t2);
			append_dev(div0, input);
			if (input.autofocus) input.focus();
			/*input_binding*/ ctx[41](input);
			set_input_value(input, /*value*/ ctx[0]);
			append_dev(div1, t3);
			if (if_block) if_block.m(div1, null);
			append_dev(div1, t4);

			if (append_slot) {
				append_slot.m(div1, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*input_input_handler*/ ctx[42]),
					listen_dev(input, "focus", /*onFocus*/ ctx[24], false, false, false),
					listen_dev(input, "blur", /*onBlur*/ ctx[25], false, false, false),
					listen_dev(input, "input", /*onInput*/ ctx[27], false, false, false),
					listen_dev(input, "focus", /*focus_handler*/ ctx[34], false, false, false),
					listen_dev(input, "blur", /*blur_handler*/ ctx[35], false, false, false),
					listen_dev(input, "input", /*input_handler*/ ctx[36], false, false, false),
					listen_dev(input, "change", /*change_handler*/ ctx[37], false, false, false),
					listen_dev(input, "keypress", /*keypress_handler*/ ctx[38], false, false, false),
					listen_dev(input, "keydown", /*keydown_handler*/ ctx[39], false, false, false),
					listen_dev(input, "keyup", /*keyup_handler*/ ctx[40], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (prepend_slot) {
				if (prepend_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
					update_slot_base(
						prepend_slot,
						prepend_slot_template,
						ctx,
						/*$$scope*/ ctx[43],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
						: get_slot_changes(prepend_slot_template, /*$$scope*/ ctx[43], dirty, get_prepend_slot_changes),
						get_prepend_slot_context
					);
				}
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[43],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[43], dirty, null),
						null
					);
				}
			}

			if (!current || dirty[0] & /*id*/ 1048576) {
				attr_dev(label, "for", /*id*/ ctx[20]);
			}

			if (dirty[0] & /*labelActive*/ 8388608) {
				toggle_class(label, "active", /*labelActive*/ ctx[23]);
			}

			if (content_slot) {
				if (content_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
					update_slot_base(
						content_slot,
						content_slot_template,
						ctx,
						/*$$scope*/ ctx[43],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[43], dirty, get_content_slot_changes),
						get_content_slot_context
					);
				}
			}

			set_attributes(input, input_data = get_spread_update(input_levels, [
				{ type: "text" },
				(!current || dirty[0] & /*placeholder*/ 16384) && { placeholder: /*placeholder*/ ctx[14] },
				(!current || dirty[0] & /*id*/ 1048576) && { id: /*id*/ ctx[20] },
				(!current || dirty[0] & /*readonly*/ 4096) && { readOnly: /*readonly*/ ctx[12] },
				(!current || dirty[0] & /*disabled*/ 8192) && { disabled: /*disabled*/ ctx[13] },
				dirty[0] & /*$$restProps*/ 268435456 && /*$$restProps*/ ctx[28]
			]));

			if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (/*clearable*/ ctx[11] && /*value*/ ctx[0] !== '') {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*clearable, value*/ 2049) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$3(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, t4);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (append_slot) {
				if (append_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
					update_slot_base(
						append_slot,
						append_slot_template,
						ctx,
						/*$$scope*/ ctx[43],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
						: get_slot_changes(append_slot_template, /*$$scope*/ ctx[43], dirty, get_append_slot_changes),
						get_append_slot_context
					);
				}
			}

			if (dirty[0] & /*filled*/ 32) {
				toggle_class(div1, "filled", /*filled*/ ctx[5]);
			}

			if (dirty[0] & /*solo*/ 64) {
				toggle_class(div1, "solo", /*solo*/ ctx[6]);
			}

			if (dirty[0] & /*outlined*/ 128) {
				toggle_class(div1, "outlined", /*outlined*/ ctx[7]);
			}

			if (dirty[0] & /*flat*/ 256) {
				toggle_class(div1, "flat", /*flat*/ ctx[8]);
			}

			if (dirty[0] & /*rounded*/ 1024) {
				toggle_class(div1, "rounded", /*rounded*/ ctx[10]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(prepend_slot, local);
			transition_in(default_slot, local);
			transition_in(content_slot, local);
			transition_in(if_block);
			transition_in(append_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(prepend_slot, local);
			transition_out(default_slot, local);
			transition_out(content_slot, local);
			transition_out(if_block);
			transition_out(append_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (prepend_slot) prepend_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			if (content_slot) content_slot.d(detaching);
			/*input_binding*/ ctx[41](null);
			if (if_block) if_block.d();
			if (append_slot) append_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(64:0) <Input    class=\\\"s-text-field {klass}\\\"    {color}    {dense}    {readonly}    {disabled}    {error}    {success}    {style}>",
		ctx
	});

	return block;
}

// (74:2) 
function create_prepend_outer_slot(ctx) {
	let current;
	const prepend_outer_slot_template = /*#slots*/ ctx[33]["prepend-outer"];
	const prepend_outer_slot = create_slot(prepend_outer_slot_template, ctx, /*$$scope*/ ctx[43], get_prepend_outer_slot_context);

	const block = {
		c: function create() {
			if (prepend_outer_slot) prepend_outer_slot.c();
		},
		m: function mount(target, anchor) {
			if (prepend_outer_slot) {
				prepend_outer_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (prepend_outer_slot) {
				if (prepend_outer_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
					update_slot_base(
						prepend_outer_slot,
						prepend_outer_slot_template,
						ctx,
						/*$$scope*/ ctx[43],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
						: get_slot_changes(prepend_outer_slot_template, /*$$scope*/ ctx[43], dirty, get_prepend_outer_slot_changes),
						get_prepend_outer_slot_context
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(prepend_outer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(prepend_outer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (prepend_outer_slot) prepend_outer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_prepend_outer_slot.name,
		type: "slot",
		source: "(74:2) ",
		ctx
	});

	return block;
}

// (128:6) {#each messages as message}
function create_each_block_1$1(ctx) {
	let span;
	let t_value = /*message*/ ctx[44] + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			add_location(span, file$a, 127, 33, 3082);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*messages*/ 131072 && t_value !== (t_value = /*message*/ ctx[44] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1$1.name,
		type: "each",
		source: "(128:6) {#each messages as message}",
		ctx
	});

	return block;
}

// (129:6) {#each errorMessages.slice(0, errorCount) as message}
function create_each_block$4(ctx) {
	let span;
	let t_value = /*message*/ ctx[44] + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			add_location(span, file$a, 128, 59, 3172);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*errorMessages, errorCount*/ 4456448 && t_value !== (t_value = /*message*/ ctx[44] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$4.name,
		type: "each",
		source: "(129:6) {#each errorMessages.slice(0, errorCount) as message}",
		ctx
	});

	return block;
}

// (131:4) {#if counter}
function create_if_block$4(ctx) {
	let span;
	let t0_value = /*value*/ ctx[0].length + "";
	let t0;
	let t1;
	let t2;

	const block = {
		c: function create() {
			span = element("span");
			t0 = text(t0_value);
			t1 = text(" / ");
			t2 = text(/*counter*/ ctx[16]);
			add_location(span, file$a, 130, 17, 3232);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t0);
			append_dev(span, t1);
			append_dev(span, t2);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*value*/ 1 && t0_value !== (t0_value = /*value*/ ctx[0].length + "")) set_data_dev(t0, t0_value);
			if (dirty[0] & /*counter*/ 65536) set_data_dev(t2, /*counter*/ ctx[16]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(131:4) {#if counter}",
		ctx
	});

	return block;
}

// (125:2) 
function create_messages_slot(ctx) {
	let div1;
	let div0;
	let span;
	let t0;
	let t1;
	let t2;
	let t3;
	let each_value_1 = /*messages*/ ctx[17];
	validate_each_argument(each_value_1);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
	}

	let each_value = /*errorMessages*/ ctx[22].slice(0, /*errorCount*/ ctx[18]);
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	}

	let if_block = /*counter*/ ctx[16] && create_if_block$4(ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			span = element("span");
			t0 = text(/*hint*/ ctx[15]);
			t1 = space();

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t2 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t3 = space();
			if (if_block) if_block.c();
			add_location(span, file$a, 126, 6, 3028);
			add_location(div0, file$a, 125, 4, 3015);
			attr_dev(div1, "slot", "messages");
			add_location(div1, file$a, 124, 2, 2988);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, span);
			append_dev(span, t0);
			append_dev(div0, t1);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div0, null);
			}

			append_dev(div0, t2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			append_dev(div1, t3);
			if (if_block) if_block.m(div1, null);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*hint*/ 32768) set_data_dev(t0, /*hint*/ ctx[15]);

			if (dirty[0] & /*messages*/ 131072) {
				each_value_1 = /*messages*/ ctx[17];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1$1(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(div0, t2);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if (dirty[0] & /*errorMessages, errorCount*/ 4456448) {
				each_value = /*errorMessages*/ ctx[22].slice(0, /*errorCount*/ ctx[18]);
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$4(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$4(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (/*counter*/ ctx[16]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$4(ctx);
					if_block.c();
					if_block.m(div1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_each(each_blocks_1, detaching);
			destroy_each(each_blocks, detaching);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_messages_slot.name,
		type: "slot",
		source: "(125:2) ",
		ctx
	});

	return block;
}

// (135:2) 
function create_append_outer_slot(ctx) {
	let current;
	const append_outer_slot_template = /*#slots*/ ctx[33]["append-outer"];
	const append_outer_slot = create_slot(append_outer_slot_template, ctx, /*$$scope*/ ctx[43], get_append_outer_slot_context);

	const block = {
		c: function create() {
			if (append_outer_slot) append_outer_slot.c();
		},
		m: function mount(target, anchor) {
			if (append_outer_slot) {
				append_outer_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (append_outer_slot) {
				if (append_outer_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
					update_slot_base(
						append_outer_slot,
						append_outer_slot_template,
						ctx,
						/*$$scope*/ ctx[43],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
						: get_slot_changes(append_outer_slot_template, /*$$scope*/ ctx[43], dirty, get_append_outer_slot_changes),
						get_append_outer_slot_context
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(append_outer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(append_outer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (append_outer_slot) append_outer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_append_outer_slot.name,
		type: "slot",
		source: "(135:2) ",
		ctx
	});

	return block;
}

function create_fragment$a(ctx) {
	let input;
	let current;

	input = new Input({
			props: {
				class: "s-text-field " + /*klass*/ ctx[3],
				color: /*color*/ ctx[4],
				dense: /*dense*/ ctx[9],
				readonly: /*readonly*/ ctx[12],
				disabled: /*disabled*/ ctx[13],
				error: /*error*/ ctx[1],
				success: /*success*/ ctx[19],
				style: /*style*/ ctx[21],
				$$slots: {
					"append-outer": [create_append_outer_slot],
					messages: [create_messages_slot],
					"prepend-outer": [create_prepend_outer_slot],
					default: [create_default_slot$2]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(input.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(input, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const input_changes = {};
			if (dirty[0] & /*klass*/ 8) input_changes.class = "s-text-field " + /*klass*/ ctx[3];
			if (dirty[0] & /*color*/ 16) input_changes.color = /*color*/ ctx[4];
			if (dirty[0] & /*dense*/ 512) input_changes.dense = /*dense*/ ctx[9];
			if (dirty[0] & /*readonly*/ 4096) input_changes.readonly = /*readonly*/ ctx[12];
			if (dirty[0] & /*disabled*/ 8192) input_changes.disabled = /*disabled*/ ctx[13];
			if (dirty[0] & /*error*/ 2) input_changes.error = /*error*/ ctx[1];
			if (dirty[0] & /*success*/ 524288) input_changes.success = /*success*/ ctx[19];
			if (dirty[0] & /*style*/ 2097152) input_changes.style = /*style*/ ctx[21];

			if (dirty[0] & /*counter, value, errorMessages, errorCount, messages, hint, filled, solo, outlined, flat, rounded, clearable, placeholder, id, readonly, disabled, $$restProps, inputElement, labelActive*/ 282590693 | dirty[1] & /*$$scope*/ 4096) {
				input_changes.$$scope = { dirty, ctx };
			}

			input.$set(input_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(input, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	let labelActive;

	const omit_props_names = [
		"class","value","color","filled","solo","outlined","flat","dense","rounded","clearable","readonly","disabled","placeholder","hint","counter","messages","rules","errorCount","validateOnBlur","error","success","id","style","inputElement","validate"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;

	validate_slots('TextField', slots, [
		'append-outer','prepend-outer','prepend','default','content','clear-icon','append'
	]);

	let { class: klass = '' } = $$props;
	let { value = '' } = $$props;
	let { color = 'primary' } = $$props;
	let { filled = false } = $$props;
	let { solo = false } = $$props;
	let { outlined = false } = $$props;
	let { flat = false } = $$props;
	let { dense = false } = $$props;
	let { rounded = false } = $$props;
	let { clearable = false } = $$props;
	let { readonly = false } = $$props;
	let { disabled = false } = $$props;
	let { placeholder = null } = $$props;
	let { hint = '' } = $$props;
	let { counter = false } = $$props;
	let { messages = [] } = $$props;
	let { rules = [] } = $$props;
	let { errorCount = 1 } = $$props;
	let { validateOnBlur = false } = $$props;
	let { error = false } = $$props;
	let { success = false } = $$props;
	let { id = `s-input-${uid(5)}` } = $$props;
	let { style = null } = $$props;
	let { inputElement = null } = $$props;
	let focused = false;
	let errorMessages = [];

	function validate() {
		$$invalidate(22, errorMessages = rules.map(r => r(value)).filter(r => typeof r === 'string'));

		if (errorMessages.length) $$invalidate(1, error = true); else {
			$$invalidate(1, error = false);
		}

		return error;
	}

	function onFocus() {
		$$invalidate(32, focused = true);
	}

	function onBlur() {
		$$invalidate(32, focused = false);
		if (validateOnBlur) validate();
	}

	function clear() {
		$$invalidate(0, value = '');
	}

	function onInput() {
		if (!validateOnBlur) validate();
	}

	function focus_handler(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler(event) {
		bubble.call(this, $$self, event);
	}

	function keydown_handler(event) {
		bubble.call(this, $$self, event);
	}

	function keyup_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputElement = $$value;
			$$invalidate(2, inputElement);
		});
	}

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(28, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(3, klass = $$new_props.class);
		if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ('color' in $$new_props) $$invalidate(4, color = $$new_props.color);
		if ('filled' in $$new_props) $$invalidate(5, filled = $$new_props.filled);
		if ('solo' in $$new_props) $$invalidate(6, solo = $$new_props.solo);
		if ('outlined' in $$new_props) $$invalidate(7, outlined = $$new_props.outlined);
		if ('flat' in $$new_props) $$invalidate(8, flat = $$new_props.flat);
		if ('dense' in $$new_props) $$invalidate(9, dense = $$new_props.dense);
		if ('rounded' in $$new_props) $$invalidate(10, rounded = $$new_props.rounded);
		if ('clearable' in $$new_props) $$invalidate(11, clearable = $$new_props.clearable);
		if ('readonly' in $$new_props) $$invalidate(12, readonly = $$new_props.readonly);
		if ('disabled' in $$new_props) $$invalidate(13, disabled = $$new_props.disabled);
		if ('placeholder' in $$new_props) $$invalidate(14, placeholder = $$new_props.placeholder);
		if ('hint' in $$new_props) $$invalidate(15, hint = $$new_props.hint);
		if ('counter' in $$new_props) $$invalidate(16, counter = $$new_props.counter);
		if ('messages' in $$new_props) $$invalidate(17, messages = $$new_props.messages);
		if ('rules' in $$new_props) $$invalidate(29, rules = $$new_props.rules);
		if ('errorCount' in $$new_props) $$invalidate(18, errorCount = $$new_props.errorCount);
		if ('validateOnBlur' in $$new_props) $$invalidate(30, validateOnBlur = $$new_props.validateOnBlur);
		if ('error' in $$new_props) $$invalidate(1, error = $$new_props.error);
		if ('success' in $$new_props) $$invalidate(19, success = $$new_props.success);
		if ('id' in $$new_props) $$invalidate(20, id = $$new_props.id);
		if ('style' in $$new_props) $$invalidate(21, style = $$new_props.style);
		if ('inputElement' in $$new_props) $$invalidate(2, inputElement = $$new_props.inputElement);
		if ('$$scope' in $$new_props) $$invalidate(43, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Input,
		Icon,
		uid,
		clearIcon: closeIcon,
		klass,
		value,
		color,
		filled,
		solo,
		outlined,
		flat,
		dense,
		rounded,
		clearable,
		readonly,
		disabled,
		placeholder,
		hint,
		counter,
		messages,
		rules,
		errorCount,
		validateOnBlur,
		error,
		success,
		id,
		style,
		inputElement,
		focused,
		errorMessages,
		validate,
		onFocus,
		onBlur,
		clear,
		onInput,
		labelActive
	});

	$$self.$inject_state = $$new_props => {
		if ('klass' in $$props) $$invalidate(3, klass = $$new_props.klass);
		if ('value' in $$props) $$invalidate(0, value = $$new_props.value);
		if ('color' in $$props) $$invalidate(4, color = $$new_props.color);
		if ('filled' in $$props) $$invalidate(5, filled = $$new_props.filled);
		if ('solo' in $$props) $$invalidate(6, solo = $$new_props.solo);
		if ('outlined' in $$props) $$invalidate(7, outlined = $$new_props.outlined);
		if ('flat' in $$props) $$invalidate(8, flat = $$new_props.flat);
		if ('dense' in $$props) $$invalidate(9, dense = $$new_props.dense);
		if ('rounded' in $$props) $$invalidate(10, rounded = $$new_props.rounded);
		if ('clearable' in $$props) $$invalidate(11, clearable = $$new_props.clearable);
		if ('readonly' in $$props) $$invalidate(12, readonly = $$new_props.readonly);
		if ('disabled' in $$props) $$invalidate(13, disabled = $$new_props.disabled);
		if ('placeholder' in $$props) $$invalidate(14, placeholder = $$new_props.placeholder);
		if ('hint' in $$props) $$invalidate(15, hint = $$new_props.hint);
		if ('counter' in $$props) $$invalidate(16, counter = $$new_props.counter);
		if ('messages' in $$props) $$invalidate(17, messages = $$new_props.messages);
		if ('rules' in $$props) $$invalidate(29, rules = $$new_props.rules);
		if ('errorCount' in $$props) $$invalidate(18, errorCount = $$new_props.errorCount);
		if ('validateOnBlur' in $$props) $$invalidate(30, validateOnBlur = $$new_props.validateOnBlur);
		if ('error' in $$props) $$invalidate(1, error = $$new_props.error);
		if ('success' in $$props) $$invalidate(19, success = $$new_props.success);
		if ('id' in $$props) $$invalidate(20, id = $$new_props.id);
		if ('style' in $$props) $$invalidate(21, style = $$new_props.style);
		if ('inputElement' in $$props) $$invalidate(2, inputElement = $$new_props.inputElement);
		if ('focused' in $$props) $$invalidate(32, focused = $$new_props.focused);
		if ('errorMessages' in $$props) $$invalidate(22, errorMessages = $$new_props.errorMessages);
		if ('labelActive' in $$props) $$invalidate(23, labelActive = $$new_props.labelActive);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*placeholder, value*/ 16385 | $$self.$$.dirty[1] & /*focused*/ 2) {
			$$invalidate(23, labelActive = !!placeholder || value || focused);
		}
	};

	return [
		value,
		error,
		inputElement,
		klass,
		color,
		filled,
		solo,
		outlined,
		flat,
		dense,
		rounded,
		clearable,
		readonly,
		disabled,
		placeholder,
		hint,
		counter,
		messages,
		errorCount,
		success,
		id,
		style,
		errorMessages,
		labelActive,
		onFocus,
		onBlur,
		clear,
		onInput,
		$$restProps,
		rules,
		validateOnBlur,
		validate,
		focused,
		slots,
		focus_handler,
		blur_handler,
		input_handler,
		change_handler,
		keypress_handler,
		keydown_handler,
		keyup_handler,
		input_binding,
		input_input_handler,
		$$scope
	];
}

class TextField extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$a,
			create_fragment$a,
			safe_not_equal,
			{
				class: 3,
				value: 0,
				color: 4,
				filled: 5,
				solo: 6,
				outlined: 7,
				flat: 8,
				dense: 9,
				rounded: 10,
				clearable: 11,
				readonly: 12,
				disabled: 13,
				placeholder: 14,
				hint: 15,
				counter: 16,
				messages: 17,
				rules: 29,
				errorCount: 18,
				validateOnBlur: 30,
				error: 1,
				success: 19,
				id: 20,
				style: 21,
				inputElement: 2,
				validate: 31
			},
			null,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TextField",
			options,
			id: create_fragment$a.name
		});
	}

	get class() {
		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get filled() {
		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set filled(value) {
		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get solo() {
		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set solo(value) {
		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get outlined() {
		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set outlined(value) {
		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get flat() {
		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set flat(value) {
		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dense() {
		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dense(value) {
		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rounded() {
		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rounded(value) {
		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get clearable() {
		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set clearable(value) {
		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get readonly() {
		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placeholder() {
		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placeholder(value) {
		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hint() {
		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hint(value) {
		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get counter() {
		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set counter(value) {
		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get messages() {
		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set messages(value) {
		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rules() {
		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rules(value) {
		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get errorCount() {
		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errorCount(value) {
		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get validateOnBlur() {
		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set validateOnBlur(value) {
		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get error() {
		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set error(value) {
		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get success() {
		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set success(value) {
		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputElement() {
		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputElement(value) {
		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get validate() {
		return this.$$.ctx[31];
	}

	set validate(value) {
		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/svelte-materialify/dist/components/Grid/Row.svelte generated by Svelte v3.42.1 */

const file$9 = "node_modules/svelte-materialify/dist/components/Grid/Row.svelte";

function add_css$8(target) {
	append_styles(target, "svelte-1g6j1fs", ".s-row{display:flex;flex-wrap:wrap;flex:1 1 auto;margin-right:-12px;margin-left:-12px}.s-row.dense{margin-right:-4px;margin-left:-4px}.s-row.dense>.s-col{padding:4px}.s-row.no-gutters{margin-right:0;margin-left:0}.s-row.no-gutters>.s-col{padding:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUm93LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFRMEMsTUFBQSxBQUFBLENBQUEsaVBBQXdUIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlJvdy5zdmVsdGUiXX0= */");
}

function create_fragment$9(ctx) {
	let div;
	let div_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div, "class", div_class_value = "s-row " + /*klass*/ ctx[0]);
			attr_dev(div, "style", /*style*/ ctx[3]);
			toggle_class(div, "dense", /*dense*/ ctx[1]);
			toggle_class(div, "no-gutters", /*noGutters*/ ctx[2]);
			add_location(div, file$9, 29, 0, 589);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*klass*/ 1 && div_class_value !== (div_class_value = "s-row " + /*klass*/ ctx[0])) {
				attr_dev(div, "class", div_class_value);
			}

			if (!current || dirty & /*style*/ 8) {
				attr_dev(div, "style", /*style*/ ctx[3]);
			}

			if (dirty & /*klass, dense*/ 3) {
				toggle_class(div, "dense", /*dense*/ ctx[1]);
			}

			if (dirty & /*klass, noGutters*/ 5) {
				toggle_class(div, "no-gutters", /*noGutters*/ ctx[2]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Row', slots, ['default']);
	let { class: klass = '' } = $$props;
	let { dense = false } = $$props;
	let { noGutters = false } = $$props;
	let { style = null } = $$props;
	const writable_props = ['class', 'dense', 'noGutters', 'style'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Row> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('class' in $$props) $$invalidate(0, klass = $$props.class);
		if ('dense' in $$props) $$invalidate(1, dense = $$props.dense);
		if ('noGutters' in $$props) $$invalidate(2, noGutters = $$props.noGutters);
		if ('style' in $$props) $$invalidate(3, style = $$props.style);
		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ klass, dense, noGutters, style });

	$$self.$inject_state = $$props => {
		if ('klass' in $$props) $$invalidate(0, klass = $$props.klass);
		if ('dense' in $$props) $$invalidate(1, dense = $$props.dense);
		if ('noGutters' in $$props) $$invalidate(2, noGutters = $$props.noGutters);
		if ('style' in $$props) $$invalidate(3, style = $$props.style);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [klass, dense, noGutters, style, $$scope, slots];
}

class Row extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$9,
			create_fragment$9,
			safe_not_equal,
			{
				class: 0,
				dense: 1,
				noGutters: 2,
				style: 3
			},
			add_css$8
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Row",
			options,
			id: create_fragment$9.name
		});
	}

	get class() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dense() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dense(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noGutters() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noGutters(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/svelte-materialify/dist/components/Grid/Col.svelte generated by Svelte v3.42.1 */
const file$8 = "node_modules/svelte-materialify/dist/components/Grid/Col.svelte";

function add_css$7(target) {
	append_styles(target, "svelte-m400kz", ".s-col{width:100%;padding:12px;flex-basis:0;flex-grow:1;max-width:100%}.s-col.col-auto{flex:0 0 auto;width:auto;max-width:100%}.s-col.col-1{flex:0 0 8.3333333333%;max-width:8.3333333333%}.s-col.col-2{flex:0 0 16.6666666667%;max-width:16.6666666667%}.s-col.col-3{flex:0 0 25%;max-width:25%}.s-col.col-4{flex:0 0 33.3333333333%;max-width:33.3333333333%}.s-col.col-5{flex:0 0 41.6666666667%;max-width:41.6666666667%}.s-col.col-6{flex:0 0 50%;max-width:50%}.s-col.col-7{flex:0 0 58.3333333333%;max-width:58.3333333333%}.s-col.col-8{flex:0 0 66.6666666667%;max-width:66.6666666667%}.s-col.col-9{flex:0 0 75%;max-width:75%}.s-col.col-10{flex:0 0 83.3333333333%;max-width:83.3333333333%}.s-col.col-11{flex:0 0 91.6666666667%;max-width:91.6666666667%}.s-col.col-12{flex:0 0 100%;max-width:100%}.s-col.offset-1{margin-left:8.3333333333%}.s-col.offset-2{margin-left:16.6666666667%}.s-col.offset-3{margin-left:25%}.s-col.offset-4{margin-left:33.3333333333%}.s-col.offset-5{margin-left:41.6666666667%}.s-col.offset-6{margin-left:50%}.s-col.offset-7{margin-left:58.3333333333%}.s-col.offset-8{margin-left:66.6666666667%}.s-col.offset-9{margin-left:75%}.s-col.offset-10{margin-left:83.3333333333%}.s-col.offset-11{margin-left:91.6666666667%}@media only screen and (min-width: 600px){.s-col.sm-auto{flex:0 0 auto;width:auto;max-width:100%}.s-col.sm-1{flex:0 0 8.3333333333%;max-width:8.3333333333%}.s-col.sm-2{flex:0 0 16.6666666667%;max-width:16.6666666667%}.s-col.sm-3{flex:0 0 25%;max-width:25%}.s-col.sm-4{flex:0 0 33.3333333333%;max-width:33.3333333333%}.s-col.sm-5{flex:0 0 41.6666666667%;max-width:41.6666666667%}.s-col.sm-6{flex:0 0 50%;max-width:50%}.s-col.sm-7{flex:0 0 58.3333333333%;max-width:58.3333333333%}.s-col.sm-8{flex:0 0 66.6666666667%;max-width:66.6666666667%}.s-col.sm-9{flex:0 0 75%;max-width:75%}.s-col.sm-10{flex:0 0 83.3333333333%;max-width:83.3333333333%}.s-col.sm-11{flex:0 0 91.6666666667%;max-width:91.6666666667%}.s-col.sm-12{flex:0 0 100%;max-width:100%}.s-col.offset-sm-0{margin-left:0}.s-col.offset-sm-1{margin-left:8.3333333333%}.s-col.offset-sm-2{margin-left:16.6666666667%}.s-col.offset-sm-3{margin-left:25%}.s-col.offset-sm-4{margin-left:33.3333333333%}.s-col.offset-sm-5{margin-left:41.6666666667%}.s-col.offset-sm-6{margin-left:50%}.s-col.offset-sm-7{margin-left:58.3333333333%}.s-col.offset-sm-8{margin-left:66.6666666667%}.s-col.offset-sm-9{margin-left:75%}.s-col.offset-sm-10{margin-left:83.3333333333%}.s-col.offset-sm-11{margin-left:91.6666666667%}}@media only screen and (min-width: 960px){.s-col.md-auto{flex:0 0 auto;width:auto;max-width:100%}.s-col.md-1{flex:0 0 8.3333333333%;max-width:8.3333333333%}.s-col.md-2{flex:0 0 16.6666666667%;max-width:16.6666666667%}.s-col.md-3{flex:0 0 25%;max-width:25%}.s-col.md-4{flex:0 0 33.3333333333%;max-width:33.3333333333%}.s-col.md-5{flex:0 0 41.6666666667%;max-width:41.6666666667%}.s-col.md-6{flex:0 0 50%;max-width:50%}.s-col.md-7{flex:0 0 58.3333333333%;max-width:58.3333333333%}.s-col.md-8{flex:0 0 66.6666666667%;max-width:66.6666666667%}.s-col.md-9{flex:0 0 75%;max-width:75%}.s-col.md-10{flex:0 0 83.3333333333%;max-width:83.3333333333%}.s-col.md-11{flex:0 0 91.6666666667%;max-width:91.6666666667%}.s-col.md-12{flex:0 0 100%;max-width:100%}.s-col.offset-md-0{margin-left:0}.s-col.offset-md-1{margin-left:8.3333333333%}.s-col.offset-md-2{margin-left:16.6666666667%}.s-col.offset-md-3{margin-left:25%}.s-col.offset-md-4{margin-left:33.3333333333%}.s-col.offset-md-5{margin-left:41.6666666667%}.s-col.offset-md-6{margin-left:50%}.s-col.offset-md-7{margin-left:58.3333333333%}.s-col.offset-md-8{margin-left:66.6666666667%}.s-col.offset-md-9{margin-left:75%}.s-col.offset-md-10{margin-left:83.3333333333%}.s-col.offset-md-11{margin-left:91.6666666667%}}@media only screen and (min-width: 1264px){.s-col.lg-auto{flex:0 0 auto;width:auto;max-width:100%}.s-col.lg-1{flex:0 0 8.3333333333%;max-width:8.3333333333%}.s-col.lg-2{flex:0 0 16.6666666667%;max-width:16.6666666667%}.s-col.lg-3{flex:0 0 25%;max-width:25%}.s-col.lg-4{flex:0 0 33.3333333333%;max-width:33.3333333333%}.s-col.lg-5{flex:0 0 41.6666666667%;max-width:41.6666666667%}.s-col.lg-6{flex:0 0 50%;max-width:50%}.s-col.lg-7{flex:0 0 58.3333333333%;max-width:58.3333333333%}.s-col.lg-8{flex:0 0 66.6666666667%;max-width:66.6666666667%}.s-col.lg-9{flex:0 0 75%;max-width:75%}.s-col.lg-10{flex:0 0 83.3333333333%;max-width:83.3333333333%}.s-col.lg-11{flex:0 0 91.6666666667%;max-width:91.6666666667%}.s-col.lg-12{flex:0 0 100%;max-width:100%}.s-col.offset-lg-0{margin-left:0}.s-col.offset-lg-1{margin-left:8.3333333333%}.s-col.offset-lg-2{margin-left:16.6666666667%}.s-col.offset-lg-3{margin-left:25%}.s-col.offset-lg-4{margin-left:33.3333333333%}.s-col.offset-lg-5{margin-left:41.6666666667%}.s-col.offset-lg-6{margin-left:50%}.s-col.offset-lg-7{margin-left:58.3333333333%}.s-col.offset-lg-8{margin-left:66.6666666667%}.s-col.offset-lg-9{margin-left:75%}.s-col.offset-lg-10{margin-left:83.3333333333%}.s-col.offset-lg-11{margin-left:91.6666666667%}}@media only screen and (min-width: 1904px){.s-col.xl-auto{flex:0 0 auto;width:auto;max-width:100%}.s-col.xl-1{flex:0 0 8.3333333333%;max-width:8.3333333333%}.s-col.xl-2{flex:0 0 16.6666666667%;max-width:16.6666666667%}.s-col.xl-3{flex:0 0 25%;max-width:25%}.s-col.xl-4{flex:0 0 33.3333333333%;max-width:33.3333333333%}.s-col.xl-5{flex:0 0 41.6666666667%;max-width:41.6666666667%}.s-col.xl-6{flex:0 0 50%;max-width:50%}.s-col.xl-7{flex:0 0 58.3333333333%;max-width:58.3333333333%}.s-col.xl-8{flex:0 0 66.6666666667%;max-width:66.6666666667%}.s-col.xl-9{flex:0 0 75%;max-width:75%}.s-col.xl-10{flex:0 0 83.3333333333%;max-width:83.3333333333%}.s-col.xl-11{flex:0 0 91.6666666667%;max-width:91.6666666667%}.s-col.xl-12{flex:0 0 100%;max-width:100%}.s-col.offset-xl-0{margin-left:0}.s-col.offset-xl-1{margin-left:8.3333333333%}.s-col.offset-xl-2{margin-left:16.6666666667%}.s-col.offset-xl-3{margin-left:25%}.s-col.offset-xl-4{margin-left:33.3333333333%}.s-col.offset-xl-5{margin-left:41.6666666667%}.s-col.offset-xl-6{margin-left:50%}.s-col.offset-xl-7{margin-left:58.3333333333%}.s-col.offset-xl-8{margin-left:66.6666666667%}.s-col.offset-xl-9{margin-left:75%}.s-col.offset-xl-10{margin-left:83.3333333333%}.s-col.offset-xl-11{margin-left:91.6666666667%}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29sLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFrQjBDLE1BQUEsQUFBQSxDQUFBLHNsTUFBK3JPIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkNvbC5zdmVsdGUiXX0= */");
}

function create_fragment$8(ctx) {
	let div;
	let div_class_value;
	let Class_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div, "class", div_class_value = "s-col " + /*klass*/ ctx[0]);
			attr_dev(div, "style", /*style*/ ctx[11]);
			add_location(div, file$8, 375, 0, 9685);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = action_destroyer(Class_action = Class.call(null, div, [
					/*cols*/ ctx[1] && `col-${/*cols*/ ctx[1]}`,
					/*sm*/ ctx[2] && `sm-${/*sm*/ ctx[2]}`,
					/*md*/ ctx[3] && `md-${/*md*/ ctx[3]}`,
					/*lg*/ ctx[4] && `lg-${/*lg*/ ctx[4]}`,
					/*xl*/ ctx[5] && `xl-${/*xl*/ ctx[5]}`,
					/*offset*/ ctx[6] && `offset-${/*offset*/ ctx[6]}`,
					/*offset_sm*/ ctx[7] && `offset-sm-${/*offset_sm*/ ctx[7]}`,
					/*offset_md*/ ctx[8] && `offset-md-${/*offset_md*/ ctx[8]}`,
					/*offset_lg*/ ctx[9] && `offset-lg-${/*offset_lg*/ ctx[9]}`,
					/*offset_xl*/ ctx[10] && `offset-xl-${/*offset_xl*/ ctx[10]}`
				]));

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*klass*/ 1 && div_class_value !== (div_class_value = "s-col " + /*klass*/ ctx[0])) {
				attr_dev(div, "class", div_class_value);
			}

			if (!current || dirty & /*style*/ 2048) {
				attr_dev(div, "style", /*style*/ ctx[11]);
			}

			if (Class_action && is_function(Class_action.update) && dirty & /*cols, sm, md, lg, xl, offset, offset_sm, offset_md, offset_lg, offset_xl*/ 2046) Class_action.update.call(null, [
				/*cols*/ ctx[1] && `col-${/*cols*/ ctx[1]}`,
				/*sm*/ ctx[2] && `sm-${/*sm*/ ctx[2]}`,
				/*md*/ ctx[3] && `md-${/*md*/ ctx[3]}`,
				/*lg*/ ctx[4] && `lg-${/*lg*/ ctx[4]}`,
				/*xl*/ ctx[5] && `xl-${/*xl*/ ctx[5]}`,
				/*offset*/ ctx[6] && `offset-${/*offset*/ ctx[6]}`,
				/*offset_sm*/ ctx[7] && `offset-sm-${/*offset_sm*/ ctx[7]}`,
				/*offset_md*/ ctx[8] && `offset-md-${/*offset_md*/ ctx[8]}`,
				/*offset_lg*/ ctx[9] && `offset-lg-${/*offset_lg*/ ctx[9]}`,
				/*offset_xl*/ ctx[10] && `offset-xl-${/*offset_xl*/ ctx[10]}`
			]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Col', slots, ['default']);
	let { class: klass = '' } = $$props;
	let { cols = false } = $$props;
	let { sm = false } = $$props;
	let { md = false } = $$props;
	let { lg = false } = $$props;
	let { xl = false } = $$props;
	let { offset = false } = $$props;
	let { offset_sm = false } = $$props;
	let { offset_md = false } = $$props;
	let { offset_lg = false } = $$props;
	let { offset_xl = false } = $$props;
	let { style = null } = $$props;

	const writable_props = [
		'class',
		'cols',
		'sm',
		'md',
		'lg',
		'xl',
		'offset',
		'offset_sm',
		'offset_md',
		'offset_lg',
		'offset_xl',
		'style'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Col> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('class' in $$props) $$invalidate(0, klass = $$props.class);
		if ('cols' in $$props) $$invalidate(1, cols = $$props.cols);
		if ('sm' in $$props) $$invalidate(2, sm = $$props.sm);
		if ('md' in $$props) $$invalidate(3, md = $$props.md);
		if ('lg' in $$props) $$invalidate(4, lg = $$props.lg);
		if ('xl' in $$props) $$invalidate(5, xl = $$props.xl);
		if ('offset' in $$props) $$invalidate(6, offset = $$props.offset);
		if ('offset_sm' in $$props) $$invalidate(7, offset_sm = $$props.offset_sm);
		if ('offset_md' in $$props) $$invalidate(8, offset_md = $$props.offset_md);
		if ('offset_lg' in $$props) $$invalidate(9, offset_lg = $$props.offset_lg);
		if ('offset_xl' in $$props) $$invalidate(10, offset_xl = $$props.offset_xl);
		if ('style' in $$props) $$invalidate(11, style = $$props.style);
		if ('$$scope' in $$props) $$invalidate(12, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		Class,
		klass,
		cols,
		sm,
		md,
		lg,
		xl,
		offset,
		offset_sm,
		offset_md,
		offset_lg,
		offset_xl,
		style
	});

	$$self.$inject_state = $$props => {
		if ('klass' in $$props) $$invalidate(0, klass = $$props.klass);
		if ('cols' in $$props) $$invalidate(1, cols = $$props.cols);
		if ('sm' in $$props) $$invalidate(2, sm = $$props.sm);
		if ('md' in $$props) $$invalidate(3, md = $$props.md);
		if ('lg' in $$props) $$invalidate(4, lg = $$props.lg);
		if ('xl' in $$props) $$invalidate(5, xl = $$props.xl);
		if ('offset' in $$props) $$invalidate(6, offset = $$props.offset);
		if ('offset_sm' in $$props) $$invalidate(7, offset_sm = $$props.offset_sm);
		if ('offset_md' in $$props) $$invalidate(8, offset_md = $$props.offset_md);
		if ('offset_lg' in $$props) $$invalidate(9, offset_lg = $$props.offset_lg);
		if ('offset_xl' in $$props) $$invalidate(10, offset_xl = $$props.offset_xl);
		if ('style' in $$props) $$invalidate(11, style = $$props.style);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		klass,
		cols,
		sm,
		md,
		lg,
		xl,
		offset,
		offset_sm,
		offset_md,
		offset_lg,
		offset_xl,
		style,
		$$scope,
		slots
	];
}

class Col extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$8,
			create_fragment$8,
			safe_not_equal,
			{
				class: 0,
				cols: 1,
				sm: 2,
				md: 3,
				lg: 4,
				xl: 5,
				offset: 6,
				offset_sm: 7,
				offset_md: 8,
				offset_lg: 9,
				offset_xl: 10,
				style: 11
			},
			add_css$7
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Col",
			options,
			id: create_fragment$8.name
		});
	}

	get class() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get cols() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set cols(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sm() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sm(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get md() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set md(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get lg() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set lg(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xl() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xl(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get offset() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set offset(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get offset_sm() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set offset_sm(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get offset_md() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set offset_md(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get offset_lg() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set offset_lg(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get offset_xl() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set offset_xl(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/svelte-select/src/Item.svelte generated by Svelte v3.42.1 */

const file$7 = "node_modules/svelte-select/src/Item.svelte";

function add_css$6(target) {
	append_styles(target, "svelte-qvhau5", ".item.svelte-qvhau5{cursor:default;height:var(--height, 42px);line-height:var(--height, 42px);padding:var(--itemPadding, 0 20px);color:var(--itemColor, inherit);text-overflow:ellipsis;overflow:hidden;white-space:nowrap}.groupHeader.svelte-qvhau5{text-transform:var(--groupTitleTextTransform, uppercase)}.groupItem.svelte-qvhau5{padding-left:var(--groupItemPaddingLeft, 40px)}.item.svelte-qvhau5:active{background:var(--itemActiveBackground, #b9daff)}.item.active.svelte-qvhau5{background:var(--itemIsActiveBG, #007aff);color:var(--itemIsActiveColor, #fff)}.item.first.svelte-qvhau5{border-radius:var(--itemFirstBorderRadius, 4px 4px 0 0)}.item.hover.svelte-qvhau5:not(.active){background:var(--itemHoverBG, #e7f2ff)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSXRlbS5zdmVsdGUiLCJtYXBwaW5ncyI6IjRzQkF5REEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiSXRlbS5zdmVsdGUiXX0= */");
}

function create_fragment$7(ctx) {
	let div;
	let raw_value = /*getOptionLabel*/ ctx[0](/*item*/ ctx[1], /*filterText*/ ctx[2]) + "";
	let div_class_value;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", div_class_value = "item " + /*itemClasses*/ ctx[3] + " svelte-qvhau5");
			add_location(div, file$7, 60, 0, 1352);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			div.innerHTML = raw_value;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*getOptionLabel, item, filterText*/ 7 && raw_value !== (raw_value = /*getOptionLabel*/ ctx[0](/*item*/ ctx[1], /*filterText*/ ctx[2]) + "")) div.innerHTML = raw_value;
			if (dirty & /*itemClasses*/ 8 && div_class_value !== (div_class_value = "item " + /*itemClasses*/ ctx[3] + " svelte-qvhau5")) {
				attr_dev(div, "class", div_class_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Item', slots, []);
	let { isActive = false } = $$props;
	let { isFirst = false } = $$props;
	let { isHover = false } = $$props;
	let { getOptionLabel = undefined } = $$props;
	let { item = undefined } = $$props;
	let { filterText = '' } = $$props;
	let itemClasses = '';
	const writable_props = ['isActive', 'isFirst', 'isHover', 'getOptionLabel', 'item', 'filterText'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Item> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('isActive' in $$props) $$invalidate(4, isActive = $$props.isActive);
		if ('isFirst' in $$props) $$invalidate(5, isFirst = $$props.isFirst);
		if ('isHover' in $$props) $$invalidate(6, isHover = $$props.isHover);
		if ('getOptionLabel' in $$props) $$invalidate(0, getOptionLabel = $$props.getOptionLabel);
		if ('item' in $$props) $$invalidate(1, item = $$props.item);
		if ('filterText' in $$props) $$invalidate(2, filterText = $$props.filterText);
	};

	$$self.$capture_state = () => ({
		isActive,
		isFirst,
		isHover,
		getOptionLabel,
		item,
		filterText,
		itemClasses
	});

	$$self.$inject_state = $$props => {
		if ('isActive' in $$props) $$invalidate(4, isActive = $$props.isActive);
		if ('isFirst' in $$props) $$invalidate(5, isFirst = $$props.isFirst);
		if ('isHover' in $$props) $$invalidate(6, isHover = $$props.isHover);
		if ('getOptionLabel' in $$props) $$invalidate(0, getOptionLabel = $$props.getOptionLabel);
		if ('item' in $$props) $$invalidate(1, item = $$props.item);
		if ('filterText' in $$props) $$invalidate(2, filterText = $$props.filterText);
		if ('itemClasses' in $$props) $$invalidate(3, itemClasses = $$props.itemClasses);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*isActive, isFirst, isHover, item*/ 114) {
			{
				const classes = [];

				if (isActive) {
					classes.push('active');
				}

				if (isFirst) {
					classes.push('first');
				}

				if (isHover) {
					classes.push('hover');
				}

				if (item.isGroupHeader) {
					classes.push('groupHeader');
				}

				if (item.isGroupItem) {
					classes.push('groupItem');
				}

				$$invalidate(3, itemClasses = classes.join(' '));
			}
		}
	};

	return [getOptionLabel, item, filterText, itemClasses, isActive, isFirst, isHover];
}

class Item extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$7,
			create_fragment$7,
			safe_not_equal,
			{
				isActive: 4,
				isFirst: 5,
				isHover: 6,
				getOptionLabel: 0,
				item: 1,
				filterText: 2
			},
			add_css$6
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Item",
			options,
			id: create_fragment$7.name
		});
	}

	get isActive() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isActive(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isFirst() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isFirst(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isHover() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isHover(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getOptionLabel() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getOptionLabel(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get item() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set item(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get filterText() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set filterText(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/svelte-select/src/VirtualList.svelte generated by Svelte v3.42.1 */
const file$6 = "node_modules/svelte-select/src/VirtualList.svelte";

function add_css$5(target) {
	append_styles(target, "svelte-eh6sbr", "svelte-virtual-list-viewport.svelte-eh6sbr{position:relative;overflow-y:auto;-webkit-overflow-scrolling:touch;display:block}svelte-virtual-list-contents.svelte-eh6sbr,svelte-virtual-list-row.svelte-eh6sbr{display:block}svelte-virtual-list-row.svelte-eh6sbr{overflow:hidden}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmlydHVhbExpc3Quc3ZlbHRlIiwibWFwcGluZ3MiOiJpUkF3SkEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiVmlydHVhbExpc3Quc3ZlbHRlIl19 */");
}

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[23] = list[i];
	return child_ctx;
}

const get_default_slot_changes = dirty => ({
	item: dirty & /*visible*/ 32,
	i: dirty & /*visible*/ 32,
	hoverItemIndex: dirty & /*hoverItemIndex*/ 2
});

const get_default_slot_context = ctx => ({
	item: /*row*/ ctx[23].data,
	i: /*row*/ ctx[23].index,
	hoverItemIndex: /*hoverItemIndex*/ ctx[1]
});

// (159:57) Missing template
function fallback_block(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Missing template");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block.name,
		type: "fallback",
		source: "(159:57) Missing template",
		ctx
	});

	return block;
}

// (157:2) {#each visible as row (row.index)}
function create_each_block$3(key_1, ctx) {
	let svelte_virtual_list_row;
	let t;
	let current;
	const default_slot_template = /*#slots*/ ctx[15].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], get_default_slot_context);
	const default_slot_or_fallback = default_slot || fallback_block(ctx);

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			svelte_virtual_list_row = element("svelte-virtual-list-row");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			t = space();
			set_custom_element_data(svelte_virtual_list_row, "class", "svelte-eh6sbr");
			add_location(svelte_virtual_list_row, file$6, 157, 3, 3513);
			this.first = svelte_virtual_list_row;
		},
		m: function mount(target, anchor) {
			insert_dev(target, svelte_virtual_list_row, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(svelte_virtual_list_row, null);
			}

			append_dev(svelte_virtual_list_row, t);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope, visible, hoverItemIndex*/ 16418)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[14],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[14])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, get_default_slot_changes),
						get_default_slot_context
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(svelte_virtual_list_row);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$3.name,
		type: "each",
		source: "(157:2) {#each visible as row (row.index)}",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let svelte_virtual_list_viewport;
	let svelte_virtual_list_contents;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let svelte_virtual_list_viewport_resize_listener;
	let current;
	let mounted;
	let dispose;
	let each_value = /*visible*/ ctx[5];
	validate_each_argument(each_value);
	const get_key = ctx => /*row*/ ctx[23].index;
	validate_each_keys(ctx, each_value, get_each_context$3, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$3(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
	}

	const block = {
		c: function create() {
			svelte_virtual_list_viewport = element("svelte-virtual-list-viewport");
			svelte_virtual_list_contents = element("svelte-virtual-list-contents");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			set_style(svelte_virtual_list_contents, "padding-top", /*top*/ ctx[6] + "px");
			set_style(svelte_virtual_list_contents, "padding-bottom", /*bottom*/ ctx[7] + "px");
			set_custom_element_data(svelte_virtual_list_contents, "class", "svelte-eh6sbr");
			add_location(svelte_virtual_list_contents, file$6, 155, 1, 3363);
			set_style(svelte_virtual_list_viewport, "height", /*height*/ ctx[0]);
			set_custom_element_data(svelte_virtual_list_viewport, "class", "svelte-eh6sbr");
			add_render_callback(() => /*svelte_virtual_list_viewport_elementresize_handler*/ ctx[18].call(svelte_virtual_list_viewport));
			add_location(svelte_virtual_list_viewport, file$6, 153, 0, 3221);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svelte_virtual_list_viewport, anchor);
			append_dev(svelte_virtual_list_viewport, svelte_virtual_list_contents);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(svelte_virtual_list_contents, null);
			}

			/*svelte_virtual_list_contents_binding*/ ctx[16](svelte_virtual_list_contents);
			/*svelte_virtual_list_viewport_binding*/ ctx[17](svelte_virtual_list_viewport);
			svelte_virtual_list_viewport_resize_listener = add_resize_listener(svelte_virtual_list_viewport, /*svelte_virtual_list_viewport_elementresize_handler*/ ctx[18].bind(svelte_virtual_list_viewport));
			current = true;

			if (!mounted) {
				dispose = listen_dev(svelte_virtual_list_viewport, "scroll", /*handle_scroll*/ ctx[8], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*$$scope, visible, hoverItemIndex*/ 16418) {
				each_value = /*visible*/ ctx[5];
				validate_each_argument(each_value);
				group_outros();
				validate_each_keys(ctx, each_value, get_each_context$3, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, svelte_virtual_list_contents, outro_and_destroy_block, create_each_block$3, null, get_each_context$3);
				check_outros();
			}

			if (!current || dirty & /*top*/ 64) {
				set_style(svelte_virtual_list_contents, "padding-top", /*top*/ ctx[6] + "px");
			}

			if (!current || dirty & /*bottom*/ 128) {
				set_style(svelte_virtual_list_contents, "padding-bottom", /*bottom*/ ctx[7] + "px");
			}

			if (!current || dirty & /*height*/ 1) {
				set_style(svelte_virtual_list_viewport, "height", /*height*/ ctx[0]);
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(svelte_virtual_list_viewport);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			/*svelte_virtual_list_contents_binding*/ ctx[16](null);
			/*svelte_virtual_list_viewport_binding*/ ctx[17](null);
			svelte_virtual_list_viewport_resize_listener();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('VirtualList', slots, ['default']);
	let { items = undefined } = $$props;
	let { height = '100%' } = $$props;
	let { itemHeight = 40 } = $$props;
	let { hoverItemIndex = 0 } = $$props;
	let { start = 0 } = $$props;
	let { end = 0 } = $$props;

	// local state
	let height_map = [];

	let rows;
	let viewport;
	let contents;
	let viewport_height = 0;
	let visible;
	let mounted;
	let top = 0;
	let bottom = 0;
	let average_height;

	async function refresh(items, viewport_height, itemHeight) {
		const { scrollTop } = viewport;
		await tick(); // wait until the DOM is up to date
		let content_height = top - scrollTop;
		let i = start;

		while (content_height < viewport_height && i < items.length) {
			let row = rows[i - start];

			if (!row) {
				$$invalidate(10, end = i + 1);
				await tick(); // render the newly visible row
				row = rows[i - start];
			}

			const row_height = height_map[i] = itemHeight || row.offsetHeight;
			content_height += row_height;
			i += 1;
		}

		$$invalidate(10, end = i);
		const remaining = items.length - end;
		average_height = (top + content_height) / end;
		$$invalidate(7, bottom = remaining * average_height);
		height_map.length = items.length;
		$$invalidate(3, viewport.scrollTop = 0, viewport);
	}

	async function handle_scroll() {
		const { scrollTop } = viewport;
		const old_start = start;

		for (let v = 0; v < rows.length; v += 1) {
			height_map[start + v] = itemHeight || rows[v].offsetHeight;
		}

		let i = 0;
		let y = 0;

		while (i < items.length) {
			const row_height = height_map[i] || average_height;

			if (y + row_height > scrollTop) {
				$$invalidate(9, start = i);
				$$invalidate(6, top = y);
				break;
			}

			y += row_height;
			i += 1;
		}

		while (i < items.length) {
			y += height_map[i] || average_height;
			i += 1;
			if (y > scrollTop + viewport_height) break;
		}

		$$invalidate(10, end = i);
		const remaining = items.length - end;
		average_height = y / end;
		while (i < items.length) height_map[i++] = average_height;
		$$invalidate(7, bottom = remaining * average_height);

		// prevent jumping if we scrolled up into unknown territory
		if (start < old_start) {
			await tick();
			let expected_height = 0;
			let actual_height = 0;

			for (let i = start; i < old_start; i += 1) {
				if (rows[i - start]) {
					expected_height += height_map[i];
					actual_height += itemHeight || rows[i - start].offsetHeight;
				}
			}

			const d = actual_height - expected_height;
			viewport.scrollTo(0, scrollTop + d);
		}
	} // TODO if we overestimated the space these
	// rows would occupy we may need to add some

	// more. maybe we can just call handle_scroll again?
	// trigger initial refresh
	onMount(() => {
		rows = contents.getElementsByTagName('svelte-virtual-list-row');
		$$invalidate(13, mounted = true);
	});

	const writable_props = ['items', 'height', 'itemHeight', 'hoverItemIndex', 'start', 'end'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<VirtualList> was created with unknown prop '${key}'`);
	});

	function svelte_virtual_list_contents_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			contents = $$value;
			$$invalidate(4, contents);
		});
	}

	function svelte_virtual_list_viewport_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			viewport = $$value;
			$$invalidate(3, viewport);
		});
	}

	function svelte_virtual_list_viewport_elementresize_handler() {
		viewport_height = this.offsetHeight;
		$$invalidate(2, viewport_height);
	}

	$$self.$$set = $$props => {
		if ('items' in $$props) $$invalidate(11, items = $$props.items);
		if ('height' in $$props) $$invalidate(0, height = $$props.height);
		if ('itemHeight' in $$props) $$invalidate(12, itemHeight = $$props.itemHeight);
		if ('hoverItemIndex' in $$props) $$invalidate(1, hoverItemIndex = $$props.hoverItemIndex);
		if ('start' in $$props) $$invalidate(9, start = $$props.start);
		if ('end' in $$props) $$invalidate(10, end = $$props.end);
		if ('$$scope' in $$props) $$invalidate(14, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		tick,
		items,
		height,
		itemHeight,
		hoverItemIndex,
		start,
		end,
		height_map,
		rows,
		viewport,
		contents,
		viewport_height,
		visible,
		mounted,
		top,
		bottom,
		average_height,
		refresh,
		handle_scroll
	});

	$$self.$inject_state = $$props => {
		if ('items' in $$props) $$invalidate(11, items = $$props.items);
		if ('height' in $$props) $$invalidate(0, height = $$props.height);
		if ('itemHeight' in $$props) $$invalidate(12, itemHeight = $$props.itemHeight);
		if ('hoverItemIndex' in $$props) $$invalidate(1, hoverItemIndex = $$props.hoverItemIndex);
		if ('start' in $$props) $$invalidate(9, start = $$props.start);
		if ('end' in $$props) $$invalidate(10, end = $$props.end);
		if ('height_map' in $$props) height_map = $$props.height_map;
		if ('rows' in $$props) rows = $$props.rows;
		if ('viewport' in $$props) $$invalidate(3, viewport = $$props.viewport);
		if ('contents' in $$props) $$invalidate(4, contents = $$props.contents);
		if ('viewport_height' in $$props) $$invalidate(2, viewport_height = $$props.viewport_height);
		if ('visible' in $$props) $$invalidate(5, visible = $$props.visible);
		if ('mounted' in $$props) $$invalidate(13, mounted = $$props.mounted);
		if ('top' in $$props) $$invalidate(6, top = $$props.top);
		if ('bottom' in $$props) $$invalidate(7, bottom = $$props.bottom);
		if ('average_height' in $$props) average_height = $$props.average_height;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*items, start, end*/ 3584) {
			$$invalidate(5, visible = items.slice(start, end).map((data, i) => {
				return { index: i + start, data };
			}));
		}

		if ($$self.$$.dirty & /*mounted, items, viewport_height, itemHeight*/ 14340) {
			// whenever `items` changes, invalidate the current heightmap
			if (mounted) refresh(items, viewport_height, itemHeight);
		}
	};

	return [
		height,
		hoverItemIndex,
		viewport_height,
		viewport,
		contents,
		visible,
		top,
		bottom,
		handle_scroll,
		start,
		end,
		items,
		itemHeight,
		mounted,
		$$scope,
		slots,
		svelte_virtual_list_contents_binding,
		svelte_virtual_list_viewport_binding,
		svelte_virtual_list_viewport_elementresize_handler
	];
}

class VirtualList extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$6,
			create_fragment$6,
			safe_not_equal,
			{
				items: 11,
				height: 0,
				itemHeight: 12,
				hoverItemIndex: 1,
				start: 9,
				end: 10
			},
			add_css$5
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "VirtualList",
			options,
			id: create_fragment$6.name
		});
	}

	get items() {
		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get itemHeight() {
		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set itemHeight(value) {
		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hoverItemIndex() {
		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hoverItemIndex(value) {
		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get start() {
		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set start(value) {
		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get end() {
		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set end(value) {
		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/svelte-select/src/List.svelte generated by Svelte v3.42.1 */
const file$5 = "node_modules/svelte-select/src/List.svelte";

function add_css$4(target) {
	append_styles(target, "svelte-g6k2j", ".listContainer.svelte-g6k2j{box-shadow:var(--listShadow, 0 2px 3px 0 rgba(44, 62, 80, 0.24));border-radius:var(--listBorderRadius, 4px);max-height:var(--listMaxHeight, 250px);overflow-y:auto;background:var(--listBackground, #fff)}.virtualList.svelte-g6k2j{height:var(--virtualListHeight, 200px)}.listGroupTitle.svelte-g6k2j{color:var(--groupTitleColor, #8f8f8f);cursor:default;font-size:var(--groupTitleFontSize, 12px);font-weight:var(--groupTitleFontWeight, 600);height:var(--height, 42px);line-height:var(--height, 42px);padding:var(--groupTitlePadding, 0 20px);text-overflow:ellipsis;overflow-x:hidden;white-space:nowrap;text-transform:var(--groupTitleTextTransform, uppercase)}.empty.svelte-g6k2j{text-align:var(--listEmptyTextAlign, center);padding:var(--listEmptyPadding, 20px 0);color:var(--listEmptyColor, #78848F)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTGlzdC5zdmVsdGUiLCJtYXBwaW5ncyI6InV6QkFxU0EiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiTGlzdC5zdmVsdGUiXX0= */");
}

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[34] = list[i];
	child_ctx[36] = i;
	return child_ctx;
}

// (210:0) {#if isVirtualList}
function create_if_block_3$1(ctx) {
	let div;
	let virtuallist;
	let current;

	virtuallist = new VirtualList({
			props: {
				items: /*items*/ ctx[4],
				itemHeight: /*itemHeight*/ ctx[7],
				$$slots: {
					default: [
						create_default_slot$1,
						({ item, i }) => ({ 34: item, 36: i }),
						({ item, i }) => [0, (item ? 8 : 0) | (i ? 32 : 0)]
					]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(virtuallist.$$.fragment);
			attr_dev(div, "class", "listContainer virtualList svelte-g6k2j");
			add_location(div, file$5, 210, 0, 5850);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(virtuallist, div, null);
			/*div_binding*/ ctx[20](div);
			current = true;
		},
		p: function update(ctx, dirty) {
			const virtuallist_changes = {};
			if (dirty[0] & /*items*/ 16) virtuallist_changes.items = /*items*/ ctx[4];
			if (dirty[0] & /*itemHeight*/ 128) virtuallist_changes.itemHeight = /*itemHeight*/ ctx[7];

			if (dirty[0] & /*Item, filterText, getOptionLabel, selectedValue, optionIdentifier, hoverItemIndex, items*/ 4918 | dirty[1] & /*$$scope, item, i*/ 104) {
				virtuallist_changes.$$scope = { dirty, ctx };
			}

			virtuallist.$set(virtuallist_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(virtuallist.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(virtuallist.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(virtuallist);
			/*div_binding*/ ctx[20](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$1.name,
		type: "if",
		source: "(210:0) {#if isVirtualList}",
		ctx
	});

	return block;
}

// (213:2) <VirtualList {items} {itemHeight} let:item let:i>
function create_default_slot$1(ctx) {
	let div;
	let switch_instance;
	let current;
	let mounted;
	let dispose;
	var switch_value = /*Item*/ ctx[2];

	function switch_props(ctx) {
		return {
			props: {
				item: /*item*/ ctx[34],
				filterText: /*filterText*/ ctx[12],
				getOptionLabel: /*getOptionLabel*/ ctx[5],
				isFirst: isItemFirst(/*i*/ ctx[36]),
				isActive: isItemActive(/*item*/ ctx[34], /*selectedValue*/ ctx[8], /*optionIdentifier*/ ctx[9]),
				isHover: isItemHover(/*hoverItemIndex*/ ctx[1], /*item*/ ctx[34], /*i*/ ctx[36], /*items*/ ctx[4])
			},
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
	}

	function mouseover_handler() {
		return /*mouseover_handler*/ ctx[18](/*i*/ ctx[36]);
	}

	function click_handler(...args) {
		return /*click_handler*/ ctx[19](/*item*/ ctx[34], /*i*/ ctx[36], ...args);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (switch_instance) create_component(switch_instance.$$.fragment);
			attr_dev(div, "class", "listItem");
			add_location(div, file$5, 214, 4, 5970);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (switch_instance) {
				mount_component(switch_instance, div, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div, "mouseover", mouseover_handler, false, false, false),
					listen_dev(div, "click", click_handler, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const switch_instance_changes = {};
			if (dirty[1] & /*item*/ 8) switch_instance_changes.item = /*item*/ ctx[34];
			if (dirty[0] & /*filterText*/ 4096) switch_instance_changes.filterText = /*filterText*/ ctx[12];
			if (dirty[0] & /*getOptionLabel*/ 32) switch_instance_changes.getOptionLabel = /*getOptionLabel*/ ctx[5];
			if (dirty[1] & /*i*/ 32) switch_instance_changes.isFirst = isItemFirst(/*i*/ ctx[36]);
			if (dirty[0] & /*selectedValue, optionIdentifier*/ 768 | dirty[1] & /*item*/ 8) switch_instance_changes.isActive = isItemActive(/*item*/ ctx[34], /*selectedValue*/ ctx[8], /*optionIdentifier*/ ctx[9]);
			if (dirty[0] & /*hoverItemIndex, items*/ 18 | dirty[1] & /*item, i*/ 40) switch_instance_changes.isHover = isItemHover(/*hoverItemIndex*/ ctx[1], /*item*/ ctx[34], /*i*/ ctx[36], /*items*/ ctx[4]);

			if (switch_value !== (switch_value = /*Item*/ ctx[2])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, div, null);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (switch_instance) destroy_component(switch_instance);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(213:2) <VirtualList {items} {itemHeight} let:item let:i>",
		ctx
	});

	return block;
}

// (232:0) {#if !isVirtualList}
function create_if_block$3(ctx) {
	let div;
	let current;
	let each_value = /*items*/ ctx[4];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	let each_1_else = null;

	if (!each_value.length) {
		each_1_else = create_else_block_1$1(ctx);
	}

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			if (each_1_else) {
				each_1_else.c();
			}

			attr_dev(div, "class", "listContainer svelte-g6k2j");
			add_location(div, file$5, 232, 0, 6477);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			if (each_1_else) {
				each_1_else.m(div, null);
			}

			/*div_binding_1*/ ctx[23](div);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*getGroupHeaderLabel, items, handleHover, handleClick, Item, filterText, getOptionLabel, selectedValue, optionIdentifier, hoverItemIndex, noOptionsMessage, hideEmptyState*/ 32630) {
				each_value = /*items*/ ctx[4];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();

				if (!each_value.length && each_1_else) {
					each_1_else.p(ctx, dirty);
				} else if (!each_value.length) {
					each_1_else = create_else_block_1$1(ctx);
					each_1_else.c();
					each_1_else.m(div, null);
				} else if (each_1_else) {
					each_1_else.d(1);
					each_1_else = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
			if (each_1_else) each_1_else.d();
			/*div_binding_1*/ ctx[23](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(232:0) {#if !isVirtualList}",
		ctx
	});

	return block;
}

// (254:2) {:else}
function create_else_block_1$1(ctx) {
	let if_block_anchor;
	let if_block = !/*hideEmptyState*/ ctx[10] && create_if_block_2$2(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (!/*hideEmptyState*/ ctx[10]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_2$2(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$1.name,
		type: "else",
		source: "(254:2) {:else}",
		ctx
	});

	return block;
}

// (255:4) {#if !hideEmptyState}
function create_if_block_2$2(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(/*noOptionsMessage*/ ctx[11]);
			attr_dev(div, "class", "empty svelte-g6k2j");
			add_location(div, file$5, 255, 6, 7178);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*noOptionsMessage*/ 2048) set_data_dev(t, /*noOptionsMessage*/ ctx[11]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$2.name,
		type: "if",
		source: "(255:4) {#if !hideEmptyState}",
		ctx
	});

	return block;
}

// (237:4) { :else }
function create_else_block$2(ctx) {
	let div;
	let switch_instance;
	let t;
	let current;
	let mounted;
	let dispose;
	var switch_value = /*Item*/ ctx[2];

	function switch_props(ctx) {
		return {
			props: {
				item: /*item*/ ctx[34],
				filterText: /*filterText*/ ctx[12],
				getOptionLabel: /*getOptionLabel*/ ctx[5],
				isFirst: isItemFirst(/*i*/ ctx[36]),
				isActive: isItemActive(/*item*/ ctx[34], /*selectedValue*/ ctx[8], /*optionIdentifier*/ ctx[9]),
				isHover: isItemHover(/*hoverItemIndex*/ ctx[1], /*item*/ ctx[34], /*i*/ ctx[36], /*items*/ ctx[4])
			},
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
	}

	function mouseover_handler_1() {
		return /*mouseover_handler_1*/ ctx[21](/*i*/ ctx[36]);
	}

	function click_handler_1(...args) {
		return /*click_handler_1*/ ctx[22](/*item*/ ctx[34], /*i*/ ctx[36], ...args);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (switch_instance) create_component(switch_instance.$$.fragment);
			t = space();
			attr_dev(div, "class", "listItem");
			add_location(div, file$5, 237, 4, 6691);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (switch_instance) {
				mount_component(switch_instance, div, null);
			}

			append_dev(div, t);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div, "mouseover", mouseover_handler_1, false, false, false),
					listen_dev(div, "click", click_handler_1, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const switch_instance_changes = {};
			if (dirty[0] & /*items*/ 16) switch_instance_changes.item = /*item*/ ctx[34];
			if (dirty[0] & /*filterText*/ 4096) switch_instance_changes.filterText = /*filterText*/ ctx[12];
			if (dirty[0] & /*getOptionLabel*/ 32) switch_instance_changes.getOptionLabel = /*getOptionLabel*/ ctx[5];
			if (dirty[0] & /*items, selectedValue, optionIdentifier*/ 784) switch_instance_changes.isActive = isItemActive(/*item*/ ctx[34], /*selectedValue*/ ctx[8], /*optionIdentifier*/ ctx[9]);
			if (dirty[0] & /*hoverItemIndex, items*/ 18) switch_instance_changes.isHover = isItemHover(/*hoverItemIndex*/ ctx[1], /*item*/ ctx[34], /*i*/ ctx[36], /*items*/ ctx[4]);

			if (switch_value !== (switch_value = /*Item*/ ctx[2])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, div, t);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (switch_instance) destroy_component(switch_instance);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$2.name,
		type: "else",
		source: "(237:4) { :else }",
		ctx
	});

	return block;
}

// (235:4) {#if item.isGroupHeader && !item.isSelectable}
function create_if_block_1$2(ctx) {
	let div;
	let t_value = /*getGroupHeaderLabel*/ ctx[6](/*item*/ ctx[34]) + "";
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			attr_dev(div, "class", "listGroupTitle svelte-g6k2j");
			add_location(div, file$5, 235, 6, 6611);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*getGroupHeaderLabel, items*/ 80 && t_value !== (t_value = /*getGroupHeaderLabel*/ ctx[6](/*item*/ ctx[34]) + "")) set_data_dev(t, t_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(235:4) {#if item.isGroupHeader && !item.isSelectable}",
		ctx
	});

	return block;
}

// (234:2) {#each items as item, i}
function create_each_block$2(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1$2, create_else_block$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*item*/ ctx[34].isGroupHeader && !/*item*/ ctx[34].isSelectable) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(234:2) {#each items as item, i}",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let t;
	let if_block1_anchor;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*isVirtualList*/ ctx[3] && create_if_block_3$1(ctx);
	let if_block1 = !/*isVirtualList*/ ctx[3] && create_if_block$3(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, if_block1_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = listen_dev(window, "keydown", /*handleKeyDown*/ ctx[15], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*isVirtualList*/ ctx[3]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*isVirtualList*/ 8) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (!/*isVirtualList*/ ctx[3]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*isVirtualList*/ 8) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$3(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(if_block1_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function itemClasses(hoverItemIndex, item, itemIndex, items, selectedValue, optionIdentifier, isMulti) {
	return `${selectedValue && !isMulti && selectedValue[optionIdentifier] === item[optionIdentifier]
	? 'active '
	: ''}${hoverItemIndex === itemIndex || items.length === 1
	? 'hover'
	: ''}`;
}

function isItemActive(item, selectedValue, optionIdentifier) {
	return selectedValue && selectedValue[optionIdentifier] === item[optionIdentifier];
}

function isItemFirst(itemIndex) {
	return itemIndex === 0;
}

function isItemHover(hoverItemIndex, item, itemIndex, items) {
	return hoverItemIndex === itemIndex || items.length === 1;
}

function instance$5($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('List', slots, []);
	const dispatch = createEventDispatcher();
	let { container = undefined } = $$props;
	let { Item: Item$1 = Item } = $$props;
	let { isVirtualList = false } = $$props;
	let { items = [] } = $$props;

	let { getOptionLabel = (option, filterText) => {
		if (option) return option.isCreator
		? `Create \"${filterText}\"`
		: option.label;
	} } = $$props;

	let { getGroupHeaderLabel = option => {
		return option.label;
	} } = $$props;

	let { itemHeight = 40 } = $$props;
	let { hoverItemIndex = 0 } = $$props;
	let { selectedValue = undefined } = $$props;
	let { optionIdentifier = 'value' } = $$props;
	let { hideEmptyState = false } = $$props;
	let { noOptionsMessage = 'No options' } = $$props;
	let { isMulti = false } = $$props;
	let { activeItemIndex = 0 } = $$props;
	let { filterText = '' } = $$props;
	let isScrollingTimer = 0;
	let isScrolling = false;
	let prev_items;
	let prev_activeItemIndex;
	let prev_selectedValue;

	onMount(() => {
		if (items.length > 0 && !isMulti && selectedValue) {
			const _hoverItemIndex = items.findIndex(item => item[optionIdentifier] === selectedValue[optionIdentifier]);

			if (_hoverItemIndex) {
				$$invalidate(1, hoverItemIndex = _hoverItemIndex);
			}
		}

		scrollToActiveItem('active');

		container.addEventListener(
			'scroll',
			() => {
				clearTimeout(isScrollingTimer);

				isScrollingTimer = setTimeout(
					() => {
						isScrolling = false;
					},
					100
				);
			},
			false
		);
	});

	onDestroy(() => {
		
	}); // clearTimeout(isScrollingTimer);

	beforeUpdate(() => {
		if (items !== prev_items && items.length > 0) {
			$$invalidate(1, hoverItemIndex = 0);
		}

		// if (prev_activeItemIndex && activeItemIndex > -1) {
		//   hoverItemIndex = activeItemIndex;
		//   scrollToActiveItem('active');
		// }
		// if (prev_selectedValue && selectedValue) {
		//   scrollToActiveItem('active');
		//   if (items && !isMulti) {
		//     const hoverItemIndex = items.findIndex((item) => item[optionIdentifier] === selectedValue[optionIdentifier]);
		//     if (hoverItemIndex) {
		//       hoverItemIndex = hoverItemIndex;
		//     }
		//   }
		// }
		prev_items = items;

		prev_activeItemIndex = activeItemIndex;
		prev_selectedValue = selectedValue;
	});

	function handleSelect(item) {
		if (item.isCreator) return;
		dispatch('itemSelected', item);
	}

	function handleHover(i) {
		if (isScrolling) return;
		$$invalidate(1, hoverItemIndex = i);
	}

	function handleClick(args) {
		const { item, i, event } = args;
		event.stopPropagation();
		if (selectedValue && !isMulti && selectedValue[optionIdentifier] === item[optionIdentifier]) return closeList();

		if (item.isCreator) {
			dispatch('itemCreated', filterText);
		} else {
			$$invalidate(16, activeItemIndex = i);
			$$invalidate(1, hoverItemIndex = i);
			handleSelect(item);
		}
	}

	function closeList() {
		dispatch('closeList');
	}

	async function updateHoverItem(increment) {
		if (isVirtualList) return;
		let isNonSelectableItem = true;

		while (isNonSelectableItem) {
			if (increment > 0 && hoverItemIndex === items.length - 1) {
				$$invalidate(1, hoverItemIndex = 0);
			} else if (increment < 0 && hoverItemIndex === 0) {
				$$invalidate(1, hoverItemIndex = items.length - 1);
			} else {
				$$invalidate(1, hoverItemIndex = hoverItemIndex + increment);
			}

			isNonSelectableItem = items[hoverItemIndex].isGroupHeader && !items[hoverItemIndex].isSelectable;
		}

		await tick();
		scrollToActiveItem('hover');
	}

	function handleKeyDown(e) {
		switch (e.key) {
			case 'ArrowDown':
				e.preventDefault();
				items.length && updateHoverItem(1);
				break;
			case 'ArrowUp':
				e.preventDefault();
				items.length && updateHoverItem(-1);
				break;
			case 'Enter':
				e.preventDefault();
				if (items.length === 0) break;
				const hoverItem = items[hoverItemIndex];
				if (selectedValue && !isMulti && selectedValue[optionIdentifier] === hoverItem[optionIdentifier]) {
					closeList();
					break;
				}
				if (hoverItem.isCreator) {
					dispatch('itemCreated', filterText);
				} else {
					$$invalidate(16, activeItemIndex = hoverItemIndex);
					handleSelect(items[hoverItemIndex]);
				}
				break;
			case 'Tab':
				e.preventDefault();
				if (items.length === 0) break;
				if (selectedValue && selectedValue[optionIdentifier] === items[hoverItemIndex][optionIdentifier]) return closeList();
				$$invalidate(16, activeItemIndex = hoverItemIndex);
				handleSelect(items[hoverItemIndex]);
				break;
		}
	}

	function scrollToActiveItem(className) {
		if (isVirtualList || !container) return;
		let offsetBounding;
		const focusedElemBounding = container.querySelector(`.listItem .${className}`);

		if (focusedElemBounding) {
			offsetBounding = container.getBoundingClientRect().bottom - focusedElemBounding.getBoundingClientRect().bottom;
		}

		$$invalidate(0, container.scrollTop -= offsetBounding, container);
	}

	
	

	const writable_props = [
		'container',
		'Item',
		'isVirtualList',
		'items',
		'getOptionLabel',
		'getGroupHeaderLabel',
		'itemHeight',
		'hoverItemIndex',
		'selectedValue',
		'optionIdentifier',
		'hideEmptyState',
		'noOptionsMessage',
		'isMulti',
		'activeItemIndex',
		'filterText'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<List> was created with unknown prop '${key}'`);
	});

	const mouseover_handler = i => handleHover(i);
	const click_handler = (item, i, event) => handleClick({ item, i, event });

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			container = $$value;
			$$invalidate(0, container);
		});
	}

	const mouseover_handler_1 = i => handleHover(i);
	const click_handler_1 = (item, i, event) => handleClick({ item, i, event });

	function div_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			container = $$value;
			$$invalidate(0, container);
		});
	}

	$$self.$$set = $$props => {
		if ('container' in $$props) $$invalidate(0, container = $$props.container);
		if ('Item' in $$props) $$invalidate(2, Item$1 = $$props.Item);
		if ('isVirtualList' in $$props) $$invalidate(3, isVirtualList = $$props.isVirtualList);
		if ('items' in $$props) $$invalidate(4, items = $$props.items);
		if ('getOptionLabel' in $$props) $$invalidate(5, getOptionLabel = $$props.getOptionLabel);
		if ('getGroupHeaderLabel' in $$props) $$invalidate(6, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
		if ('itemHeight' in $$props) $$invalidate(7, itemHeight = $$props.itemHeight);
		if ('hoverItemIndex' in $$props) $$invalidate(1, hoverItemIndex = $$props.hoverItemIndex);
		if ('selectedValue' in $$props) $$invalidate(8, selectedValue = $$props.selectedValue);
		if ('optionIdentifier' in $$props) $$invalidate(9, optionIdentifier = $$props.optionIdentifier);
		if ('hideEmptyState' in $$props) $$invalidate(10, hideEmptyState = $$props.hideEmptyState);
		if ('noOptionsMessage' in $$props) $$invalidate(11, noOptionsMessage = $$props.noOptionsMessage);
		if ('isMulti' in $$props) $$invalidate(17, isMulti = $$props.isMulti);
		if ('activeItemIndex' in $$props) $$invalidate(16, activeItemIndex = $$props.activeItemIndex);
		if ('filterText' in $$props) $$invalidate(12, filterText = $$props.filterText);
	};

	$$self.$capture_state = () => ({
		beforeUpdate,
		createEventDispatcher,
		onDestroy,
		onMount,
		tick,
		dispatch,
		container,
		ItemComponent: Item,
		VirtualList,
		Item: Item$1,
		isVirtualList,
		items,
		getOptionLabel,
		getGroupHeaderLabel,
		itemHeight,
		hoverItemIndex,
		selectedValue,
		optionIdentifier,
		hideEmptyState,
		noOptionsMessage,
		isMulti,
		activeItemIndex,
		filterText,
		isScrollingTimer,
		isScrolling,
		prev_items,
		prev_activeItemIndex,
		prev_selectedValue,
		itemClasses,
		handleSelect,
		handleHover,
		handleClick,
		closeList,
		updateHoverItem,
		handleKeyDown,
		scrollToActiveItem,
		isItemActive,
		isItemFirst,
		isItemHover
	});

	$$self.$inject_state = $$props => {
		if ('container' in $$props) $$invalidate(0, container = $$props.container);
		if ('Item' in $$props) $$invalidate(2, Item$1 = $$props.Item);
		if ('isVirtualList' in $$props) $$invalidate(3, isVirtualList = $$props.isVirtualList);
		if ('items' in $$props) $$invalidate(4, items = $$props.items);
		if ('getOptionLabel' in $$props) $$invalidate(5, getOptionLabel = $$props.getOptionLabel);
		if ('getGroupHeaderLabel' in $$props) $$invalidate(6, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
		if ('itemHeight' in $$props) $$invalidate(7, itemHeight = $$props.itemHeight);
		if ('hoverItemIndex' in $$props) $$invalidate(1, hoverItemIndex = $$props.hoverItemIndex);
		if ('selectedValue' in $$props) $$invalidate(8, selectedValue = $$props.selectedValue);
		if ('optionIdentifier' in $$props) $$invalidate(9, optionIdentifier = $$props.optionIdentifier);
		if ('hideEmptyState' in $$props) $$invalidate(10, hideEmptyState = $$props.hideEmptyState);
		if ('noOptionsMessage' in $$props) $$invalidate(11, noOptionsMessage = $$props.noOptionsMessage);
		if ('isMulti' in $$props) $$invalidate(17, isMulti = $$props.isMulti);
		if ('activeItemIndex' in $$props) $$invalidate(16, activeItemIndex = $$props.activeItemIndex);
		if ('filterText' in $$props) $$invalidate(12, filterText = $$props.filterText);
		if ('isScrollingTimer' in $$props) isScrollingTimer = $$props.isScrollingTimer;
		if ('isScrolling' in $$props) isScrolling = $$props.isScrolling;
		if ('prev_items' in $$props) prev_items = $$props.prev_items;
		if ('prev_activeItemIndex' in $$props) prev_activeItemIndex = $$props.prev_activeItemIndex;
		if ('prev_selectedValue' in $$props) prev_selectedValue = $$props.prev_selectedValue;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		container,
		hoverItemIndex,
		Item$1,
		isVirtualList,
		items,
		getOptionLabel,
		getGroupHeaderLabel,
		itemHeight,
		selectedValue,
		optionIdentifier,
		hideEmptyState,
		noOptionsMessage,
		filterText,
		handleHover,
		handleClick,
		handleKeyDown,
		activeItemIndex,
		isMulti,
		mouseover_handler,
		click_handler,
		div_binding,
		mouseover_handler_1,
		click_handler_1,
		div_binding_1
	];
}

class List extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$5,
			create_fragment$5,
			safe_not_equal,
			{
				container: 0,
				Item: 2,
				isVirtualList: 3,
				items: 4,
				getOptionLabel: 5,
				getGroupHeaderLabel: 6,
				itemHeight: 7,
				hoverItemIndex: 1,
				selectedValue: 8,
				optionIdentifier: 9,
				hideEmptyState: 10,
				noOptionsMessage: 11,
				isMulti: 17,
				activeItemIndex: 16,
				filterText: 12
			},
			add_css$4,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "List",
			options,
			id: create_fragment$5.name
		});
	}

	get container() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set container(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get Item() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set Item(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isVirtualList() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isVirtualList(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get items() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getOptionLabel() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getOptionLabel(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getGroupHeaderLabel() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getGroupHeaderLabel(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get itemHeight() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set itemHeight(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hoverItemIndex() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hoverItemIndex(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selectedValue() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selectedValue(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get optionIdentifier() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set optionIdentifier(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideEmptyState() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideEmptyState(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noOptionsMessage() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noOptionsMessage(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isMulti() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isMulti(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get activeItemIndex() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set activeItemIndex(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get filterText() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set filterText(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/svelte-select/src/Selection.svelte generated by Svelte v3.42.1 */

const file$4 = "node_modules/svelte-select/src/Selection.svelte";

function add_css$3(target) {
	append_styles(target, "svelte-4fr6cn", ".selection.svelte-4fr6cn{text-overflow:ellipsis;overflow-x:hidden;white-space:nowrap}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VsZWN0aW9uLnN2ZWx0ZSIsIm1hcHBpbmdzIjoicUZBV0EiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiU2VsZWN0aW9uLnN2ZWx0ZSJdfQ== */");
}

function create_fragment$4(ctx) {
	let div;
	let raw_value = /*getSelectionLabel*/ ctx[0](/*item*/ ctx[1]) + "";

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "selection svelte-4fr6cn");
			add_location(div, file$4, 12, 0, 209);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			div.innerHTML = raw_value;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*getSelectionLabel, item*/ 3 && raw_value !== (raw_value = /*getSelectionLabel*/ ctx[0](/*item*/ ctx[1]) + "")) div.innerHTML = raw_value;		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Selection', slots, []);
	let { getSelectionLabel = undefined } = $$props;
	let { item = undefined } = $$props;
	const writable_props = ['getSelectionLabel', 'item'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Selection> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('getSelectionLabel' in $$props) $$invalidate(0, getSelectionLabel = $$props.getSelectionLabel);
		if ('item' in $$props) $$invalidate(1, item = $$props.item);
	};

	$$self.$capture_state = () => ({ getSelectionLabel, item });

	$$self.$inject_state = $$props => {
		if ('getSelectionLabel' in $$props) $$invalidate(0, getSelectionLabel = $$props.getSelectionLabel);
		if ('item' in $$props) $$invalidate(1, item = $$props.item);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [getSelectionLabel, item];
}

class Selection extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { getSelectionLabel: 0, item: 1 }, add_css$3);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Selection",
			options,
			id: create_fragment$4.name
		});
	}

	get getSelectionLabel() {
		throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getSelectionLabel(value) {
		throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get item() {
		throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set item(value) {
		throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/svelte-select/src/MultiSelection.svelte generated by Svelte v3.42.1 */
const file$3 = "node_modules/svelte-select/src/MultiSelection.svelte";

function add_css$2(target) {
	append_styles(target, "svelte-1xhm3lm", ".multiSelectItem.svelte-1xhm3lm.svelte-1xhm3lm{background:var(--multiItemBG, #EBEDEF);margin:var(--multiItemMargin, 5px 5px 0 0);border-radius:var(--multiItemBorderRadius, 16px);height:var(--multiItemHeight, 32px);line-height:var(--multiItemHeight, 32px);display:flex;cursor:default;padding:var(--multiItemPadding, 0 10px 0 15px);max-width:100%}.multiSelectItem_label.svelte-1xhm3lm.svelte-1xhm3lm{margin:var(--multiLabelMargin, 0 5px 0 0);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.multiSelectItem.svelte-1xhm3lm.svelte-1xhm3lm:hover,.multiSelectItem.active.svelte-1xhm3lm.svelte-1xhm3lm{background-color:var(--multiItemActiveBG, #006FFF);color:var(--multiItemActiveColor, #fff)}.multiSelectItem.disabled.svelte-1xhm3lm.svelte-1xhm3lm:hover{background:var(--multiItemDisabledHoverBg, #EBEDEF);color:var(--multiItemDisabledHoverColor, #C1C6CC)}.multiSelectItem_clear.svelte-1xhm3lm.svelte-1xhm3lm{border-radius:var(--multiClearRadius, 50%);background:var(--multiClearBG, #52616F);min-width:var(--multiClearWidth, 16px);max-width:var(--multiClearWidth, 16px);height:var(--multiClearHeight, 16px);position:relative;top:var(--multiClearTop, 8px);text-align:var(--multiClearTextAlign, center);padding:var(--multiClearPadding, 1px)}.multiSelectItem_clear.svelte-1xhm3lm.svelte-1xhm3lm:hover,.active.svelte-1xhm3lm .multiSelectItem_clear.svelte-1xhm3lm{background:var(--multiClearHoverBG, #fff)}.multiSelectItem_clear.svelte-1xhm3lm:hover svg.svelte-1xhm3lm,.active.svelte-1xhm3lm .multiSelectItem_clear svg.svelte-1xhm3lm{fill:var(--multiClearHoverFill, #006FFF)}.multiSelectItem_clear.svelte-1xhm3lm svg.svelte-1xhm3lm{fill:var(--multiClearFill, #EBEDEF);vertical-align:top}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTXVsdGlTZWxlY3Rpb24uc3ZlbHRlIiwibWFwcGluZ3MiOiJzcERBNEZBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIk11bHRpU2VsZWN0aW9uLnN2ZWx0ZSJdfQ== */");
}

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	child_ctx[11] = i;
	return child_ctx;
}

// (23:2) {#if !isDisabled && !multiFullItemClearable}
function create_if_block$2(ctx) {
	let div;
	let svg;
	let path;
	let mounted;
	let dispose;

	function click_handler(...args) {
		return /*click_handler*/ ctx[6](/*i*/ ctx[11], ...args);
	}

	const block = {
		c: function create() {
			div = element("div");
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124 l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z");
			add_location(path, file$3, 25, 6, 950);
			attr_dev(svg, "width", "100%");
			attr_dev(svg, "height", "100%");
			attr_dev(svg, "viewBox", "-2 -2 50 50");
			attr_dev(svg, "focusable", "false");
			attr_dev(svg, "role", "presentation");
			attr_dev(svg, "class", "svelte-1xhm3lm");
			add_location(svg, file$3, 24, 4, 851);
			attr_dev(div, "class", "multiSelectItem_clear svelte-1xhm3lm");
			add_location(div, file$3, 23, 2, 767);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, svg);
			append_dev(svg, path);

			if (!mounted) {
				dispose = listen_dev(div, "click", click_handler, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(23:2) {#if !isDisabled && !multiFullItemClearable}",
		ctx
	});

	return block;
}

// (18:0) {#each selectedValue as value, i}
function create_each_block$1(ctx) {
	let div1;
	let div0;
	let raw_value = /*getSelectionLabel*/ ctx[4](/*value*/ ctx[9]) + "";
	let t0;
	let t1;
	let div1_class_value;
	let mounted;
	let dispose;
	let if_block = !/*isDisabled*/ ctx[2] && !/*multiFullItemClearable*/ ctx[3] && create_if_block$2(ctx);

	function click_handler_1(...args) {
		return /*click_handler_1*/ ctx[7](/*i*/ ctx[11], ...args);
	}

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			attr_dev(div0, "class", "multiSelectItem_label svelte-1xhm3lm");
			add_location(div0, file$3, 19, 2, 636);

			attr_dev(div1, "class", div1_class_value = "multiSelectItem " + (/*activeSelectedValue*/ ctx[1] === /*i*/ ctx[11]
			? 'active'
			: '') + " " + (/*isDisabled*/ ctx[2] ? 'disabled' : '') + " svelte-1xhm3lm");

			add_location(div1, file$3, 18, 0, 457);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			div0.innerHTML = raw_value;
			append_dev(div1, t0);
			if (if_block) if_block.m(div1, null);
			append_dev(div1, t1);

			if (!mounted) {
				dispose = listen_dev(div1, "click", click_handler_1, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*getSelectionLabel, selectedValue*/ 17 && raw_value !== (raw_value = /*getSelectionLabel*/ ctx[4](/*value*/ ctx[9]) + "")) div0.innerHTML = raw_value;
			if (!/*isDisabled*/ ctx[2] && !/*multiFullItemClearable*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					if_block.m(div1, t1);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*activeSelectedValue, isDisabled*/ 6 && div1_class_value !== (div1_class_value = "multiSelectItem " + (/*activeSelectedValue*/ ctx[1] === /*i*/ ctx[11]
			? 'active'
			: '') + " " + (/*isDisabled*/ ctx[2] ? 'disabled' : '') + " svelte-1xhm3lm")) {
				attr_dev(div1, "class", div1_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(18:0) {#each selectedValue as value, i}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let each_1_anchor;
	let each_value = /*selectedValue*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*activeSelectedValue, isDisabled, multiFullItemClearable, handleClear, getSelectionLabel, selectedValue*/ 63) {
				each_value = /*selectedValue*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('MultiSelection', slots, []);
	const dispatch = createEventDispatcher();
	let { selectedValue = [] } = $$props;
	let { activeSelectedValue = undefined } = $$props;
	let { isDisabled = false } = $$props;
	let { multiFullItemClearable = false } = $$props;
	let { getSelectionLabel = undefined } = $$props;

	function handleClear(i, event) {
		event.stopPropagation();
		dispatch('multiItemClear', { i });
	}

	const writable_props = [
		'selectedValue',
		'activeSelectedValue',
		'isDisabled',
		'multiFullItemClearable',
		'getSelectionLabel'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MultiSelection> was created with unknown prop '${key}'`);
	});

	const click_handler = (i, event) => handleClear(i, event);
	const click_handler_1 = (i, event) => multiFullItemClearable ? handleClear(i, event) : {};

	$$self.$$set = $$props => {
		if ('selectedValue' in $$props) $$invalidate(0, selectedValue = $$props.selectedValue);
		if ('activeSelectedValue' in $$props) $$invalidate(1, activeSelectedValue = $$props.activeSelectedValue);
		if ('isDisabled' in $$props) $$invalidate(2, isDisabled = $$props.isDisabled);
		if ('multiFullItemClearable' in $$props) $$invalidate(3, multiFullItemClearable = $$props.multiFullItemClearable);
		if ('getSelectionLabel' in $$props) $$invalidate(4, getSelectionLabel = $$props.getSelectionLabel);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		dispatch,
		selectedValue,
		activeSelectedValue,
		isDisabled,
		multiFullItemClearable,
		getSelectionLabel,
		handleClear
	});

	$$self.$inject_state = $$props => {
		if ('selectedValue' in $$props) $$invalidate(0, selectedValue = $$props.selectedValue);
		if ('activeSelectedValue' in $$props) $$invalidate(1, activeSelectedValue = $$props.activeSelectedValue);
		if ('isDisabled' in $$props) $$invalidate(2, isDisabled = $$props.isDisabled);
		if ('multiFullItemClearable' in $$props) $$invalidate(3, multiFullItemClearable = $$props.multiFullItemClearable);
		if ('getSelectionLabel' in $$props) $$invalidate(4, getSelectionLabel = $$props.getSelectionLabel);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		selectedValue,
		activeSelectedValue,
		isDisabled,
		multiFullItemClearable,
		getSelectionLabel,
		handleClear,
		click_handler,
		click_handler_1
	];
}

class MultiSelection extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$3,
			create_fragment$3,
			safe_not_equal,
			{
				selectedValue: 0,
				activeSelectedValue: 1,
				isDisabled: 2,
				multiFullItemClearable: 3,
				getSelectionLabel: 4
			},
			add_css$2
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MultiSelection",
			options,
			id: create_fragment$3.name
		});
	}

	get selectedValue() {
		throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selectedValue(value) {
		throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get activeSelectedValue() {
		throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set activeSelectedValue(value) {
		throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isDisabled() {
		throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isDisabled(value) {
		throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get multiFullItemClearable() {
		throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set multiFullItemClearable(value) {
		throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getSelectionLabel() {
		throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getSelectionLabel(value) {
		throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function isOutOfViewport(elem) {
  const bounding = elem.getBoundingClientRect();
  const out = {};

  out.top = bounding.top < 0;
  out.left = bounding.left < 0;
  out.bottom = bounding.bottom > (window.innerHeight || document.documentElement.clientHeight);
  out.right = bounding.right > (window.innerWidth || document.documentElement.clientWidth);
  out.any = out.top || out.left || out.bottom || out.right;

  return out;
}

function debounce(func, wait, immediate) {
  let timeout;

  return function executedFunction() {
    let context = this;
    let args = arguments;

    let later = function() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };

    let callNow = immediate && !timeout;

    clearTimeout(timeout);

    timeout = setTimeout(later, wait);

    if (callNow) func.apply(context, args);
  };
}

/* node_modules/svelte-select/src/ClearIcon.svelte generated by Svelte v3.42.1 */

const file$2 = "node_modules/svelte-select/src/ClearIcon.svelte";

function create_fragment$2(ctx) {
	let svg;
	let path;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "fill", "currentColor");
			attr_dev(path, "d", "M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124\n    l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z");
			add_location(path, file$2, 7, 2, 108);
			attr_dev(svg, "width", "100%");
			attr_dev(svg, "height", "100%");
			attr_dev(svg, "viewBox", "-2 -2 50 50");
			attr_dev(svg, "focusable", "false");
			attr_dev(svg, "role", "presentation");
			add_location(svg, file$2, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ClearIcon', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ClearIcon> was created with unknown prop '${key}'`);
	});

	return [];
}

class ClearIcon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ClearIcon",
			options,
			id: create_fragment$2.name
		});
	}
}

/* node_modules/svelte-select/src/Select.svelte generated by Svelte v3.42.1 */

const { Object: Object_1, console: console_1 } = globals;
const file$1 = "node_modules/svelte-select/src/Select.svelte";

function add_css$1(target) {
	append_styles(target, "svelte-1gdq94k", ".selectContainer.svelte-1gdq94k.svelte-1gdq94k{--padding:0 16px;border:var(--border, 1px solid #d8dbdf);border-radius:var(--borderRadius, 3px);height:var(--height, 42px);position:relative;display:flex;align-items:center;padding:var(--padding);background:var(--background, #fff)}.selectContainer.svelte-1gdq94k input.svelte-1gdq94k{cursor:default;border:none;color:var(--inputColor, #3f4f5f);height:var(--height, 42px);line-height:var(--height, 42px);padding:var(--inputPadding, var(--padding));width:100%;background:transparent;font-size:var(--inputFontSize, 14px);letter-spacing:var(--inputLetterSpacing, -0.08px);position:absolute;left:var(--inputLeft, 0)}.selectContainer.svelte-1gdq94k input.svelte-1gdq94k::placeholder{color:var(--placeholderColor, #78848f);opacity:var(--placeholderOpacity, 1)}.selectContainer.svelte-1gdq94k input.svelte-1gdq94k:focus{outline:none}.selectContainer.svelte-1gdq94k.svelte-1gdq94k:hover{border-color:var(--borderHoverColor, #b2b8bf)}.selectContainer.focused.svelte-1gdq94k.svelte-1gdq94k{border-color:var(--borderFocusColor, #006fe8)}.selectContainer.disabled.svelte-1gdq94k.svelte-1gdq94k{background:var(--disabledBackground, #ebedef);border-color:var(--disabledBorderColor, #ebedef);color:var(--disabledColor, #c1c6cc)}.selectContainer.disabled.svelte-1gdq94k input.svelte-1gdq94k::placeholder{color:var(--disabledPlaceholderColor, #c1c6cc);opacity:var(--disabledPlaceholderOpacity, 1)}.selectedItem.svelte-1gdq94k.svelte-1gdq94k{line-height:var(--height, 42px);height:var(--height, 42px);overflow-x:hidden;padding:var(--selectedItemPadding, 0 20px 0 0)}.selectedItem.svelte-1gdq94k.svelte-1gdq94k:focus{outline:none}.clearSelect.svelte-1gdq94k.svelte-1gdq94k{position:absolute;right:var(--clearSelectRight, 10px);top:var(--clearSelectTop, 11px);bottom:var(--clearSelectBottom, 11px);width:var(--clearSelectWidth, 20px);color:var(--clearSelectColor, #c5cacf);flex:none !important}.clearSelect.svelte-1gdq94k.svelte-1gdq94k:hover{color:var(--clearSelectHoverColor, #2c3e50)}.selectContainer.focused.svelte-1gdq94k .clearSelect.svelte-1gdq94k{color:var(--clearSelectFocusColor, #3f4f5f)}.indicator.svelte-1gdq94k.svelte-1gdq94k{position:absolute;right:var(--indicatorRight, 10px);top:var(--indicatorTop, 11px);width:var(--indicatorWidth, 20px);height:var(--indicatorHeight, 20px);color:var(--indicatorColor, #c5cacf)}.indicator.svelte-1gdq94k svg.svelte-1gdq94k{display:inline-block;fill:var(--indicatorFill, currentcolor);line-height:1;stroke:var(--indicatorStroke, currentcolor);stroke-width:0}.spinner.svelte-1gdq94k.svelte-1gdq94k{position:absolute;right:var(--spinnerRight, 10px);top:var(--spinnerLeft, 11px);width:var(--spinnerWidth, 20px);height:var(--spinnerHeight, 20px);color:var(--spinnerColor, #51ce6c);animation:svelte-1gdq94k-rotate 0.75s linear infinite}.spinner_icon.svelte-1gdq94k.svelte-1gdq94k{display:block;height:100%;transform-origin:center center;width:100%;position:absolute;top:0;bottom:0;left:0;right:0;margin:auto;-webkit-transform:none}.spinner_path.svelte-1gdq94k.svelte-1gdq94k{stroke-dasharray:90;stroke-linecap:round}.multiSelect.svelte-1gdq94k.svelte-1gdq94k{display:flex;padding:var(--multiSelectPadding, 0 35px 0 16px);height:auto;flex-wrap:wrap;align-items:stretch}.multiSelect.svelte-1gdq94k>.svelte-1gdq94k{flex:1 1 50px}.selectContainer.multiSelect.svelte-1gdq94k input.svelte-1gdq94k{padding:var(--multiSelectInputPadding, 0);position:relative;margin:var(--multiSelectInputMargin, 0)}.hasError.svelte-1gdq94k.svelte-1gdq94k{border:var(--errorBorder, 1px solid #ff2d55);background:var(--errorBackground, #fff)}@keyframes svelte-1gdq94k-rotate{100%{transform:rotate(360deg)}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VsZWN0LnN2ZWx0ZSIsIm1hcHBpbmdzIjoibWtIQXl5QkEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiU2VsZWN0LnN2ZWx0ZSJdfQ== */");
}

// (826:2) {#if Icon}
function create_if_block_7(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [/*iconProps*/ ctx[18]];
	var switch_value = /*Icon*/ ctx[17];

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props());
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_instance_changes = (dirty[0] & /*iconProps*/ 262144)
			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*iconProps*/ ctx[18])])
			: {};

			if (switch_value !== (switch_value = /*Icon*/ ctx[17])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props());
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7.name,
		type: "if",
		source: "(826:2) {#if Icon}",
		ctx
	});

	return block;
}

// (830:2) {#if isMulti && selectedValue && selectedValue.length > 0}
function create_if_block_6(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	var switch_value = /*MultiSelection*/ ctx[7];

	function switch_props(ctx) {
		return {
			props: {
				selectedValue: /*selectedValue*/ ctx[0],
				getSelectionLabel: /*getSelectionLabel*/ ctx[13],
				activeSelectedValue: /*activeSelectedValue*/ ctx[25],
				isDisabled: /*isDisabled*/ ctx[10],
				multiFullItemClearable: /*multiFullItemClearable*/ ctx[9]
			},
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
		switch_instance.$on("multiItemClear", /*handleMultiItemClear*/ ctx[29]);
		switch_instance.$on("focus", /*handleFocus*/ ctx[32]);
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_instance_changes = {};
			if (dirty[0] & /*selectedValue*/ 1) switch_instance_changes.selectedValue = /*selectedValue*/ ctx[0];
			if (dirty[0] & /*getSelectionLabel*/ 8192) switch_instance_changes.getSelectionLabel = /*getSelectionLabel*/ ctx[13];
			if (dirty[0] & /*activeSelectedValue*/ 33554432) switch_instance_changes.activeSelectedValue = /*activeSelectedValue*/ ctx[25];
			if (dirty[0] & /*isDisabled*/ 1024) switch_instance_changes.isDisabled = /*isDisabled*/ ctx[10];
			if (dirty[0] & /*multiFullItemClearable*/ 512) switch_instance_changes.multiFullItemClearable = /*multiFullItemClearable*/ ctx[9];

			if (switch_value !== (switch_value = /*MultiSelection*/ ctx[7])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					switch_instance.$on("multiItemClear", /*handleMultiItemClear*/ ctx[29]);
					switch_instance.$on("focus", /*handleFocus*/ ctx[32]);
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(830:2) {#if isMulti && selectedValue && selectedValue.length > 0}",
		ctx
	});

	return block;
}

// (851:2) {:else}
function create_else_block_1(ctx) {
	let input_1;
	let mounted;
	let dispose;

	let input_1_levels = [
		/*_inputAttributes*/ ctx[26],
		{ placeholder: /*placeholderText*/ ctx[27] },
		{ style: /*inputStyles*/ ctx[15] }
	];

	let input_1_data = {};

	for (let i = 0; i < input_1_levels.length; i += 1) {
		input_1_data = assign(input_1_data, input_1_levels[i]);
	}

	const block = {
		c: function create() {
			input_1 = element("input");
			set_attributes(input_1, input_1_data);
			toggle_class(input_1, "svelte-1gdq94k", true);
			add_location(input_1, file$1, 851, 4, 21496);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input_1, anchor);
			if (input_1.autofocus) input_1.focus();
			/*input_1_binding_1*/ ctx[63](input_1);
			set_input_value(input_1, /*filterText*/ ctx[1]);

			if (!mounted) {
				dispose = [
					listen_dev(input_1, "focus", /*handleFocus*/ ctx[32], false, false, false),
					listen_dev(input_1, "input", /*input_1_input_handler_1*/ ctx[64])
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(input_1, input_1_data = get_spread_update(input_1_levels, [
				dirty[0] & /*_inputAttributes*/ 67108864 && /*_inputAttributes*/ ctx[26],
				dirty[0] & /*placeholderText*/ 134217728 && { placeholder: /*placeholderText*/ ctx[27] },
				dirty[0] & /*inputStyles*/ 32768 && { style: /*inputStyles*/ ctx[15] }
			]));

			if (dirty[0] & /*filterText*/ 2 && input_1.value !== /*filterText*/ ctx[1]) {
				set_input_value(input_1, /*filterText*/ ctx[1]);
			}

			toggle_class(input_1, "svelte-1gdq94k", true);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input_1);
			/*input_1_binding_1*/ ctx[63](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(851:2) {:else}",
		ctx
	});

	return block;
}

// (842:2) {#if isDisabled}
function create_if_block_5(ctx) {
	let input_1;
	let mounted;
	let dispose;

	let input_1_levels = [
		/*_inputAttributes*/ ctx[26],
		{ placeholder: /*placeholderText*/ ctx[27] },
		{ style: /*inputStyles*/ ctx[15] },
		{ disabled: true }
	];

	let input_1_data = {};

	for (let i = 0; i < input_1_levels.length; i += 1) {
		input_1_data = assign(input_1_data, input_1_levels[i]);
	}

	const block = {
		c: function create() {
			input_1 = element("input");
			set_attributes(input_1, input_1_data);
			toggle_class(input_1, "svelte-1gdq94k", true);
			add_location(input_1, file$1, 842, 4, 21284);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input_1, anchor);
			if (input_1.autofocus) input_1.focus();
			/*input_1_binding*/ ctx[61](input_1);
			set_input_value(input_1, /*filterText*/ ctx[1]);

			if (!mounted) {
				dispose = [
					listen_dev(input_1, "focus", /*handleFocus*/ ctx[32], false, false, false),
					listen_dev(input_1, "input", /*input_1_input_handler*/ ctx[62])
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(input_1, input_1_data = get_spread_update(input_1_levels, [
				dirty[0] & /*_inputAttributes*/ 67108864 && /*_inputAttributes*/ ctx[26],
				dirty[0] & /*placeholderText*/ 134217728 && { placeholder: /*placeholderText*/ ctx[27] },
				dirty[0] & /*inputStyles*/ 32768 && { style: /*inputStyles*/ ctx[15] },
				{ disabled: true }
			]));

			if (dirty[0] & /*filterText*/ 2 && input_1.value !== /*filterText*/ ctx[1]) {
				set_input_value(input_1, /*filterText*/ ctx[1]);
			}

			toggle_class(input_1, "svelte-1gdq94k", true);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input_1);
			/*input_1_binding*/ ctx[61](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(842:2) {#if isDisabled}",
		ctx
	});

	return block;
}

// (861:2) {#if !isMulti && showSelectedItem}
function create_if_block_4(ctx) {
	let div;
	let switch_instance;
	let current;
	let mounted;
	let dispose;
	var switch_value = /*Selection*/ ctx[6];

	function switch_props(ctx) {
		return {
			props: {
				item: /*selectedValue*/ ctx[0],
				getSelectionLabel: /*getSelectionLabel*/ ctx[13]
			},
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
	}

	const block = {
		c: function create() {
			div = element("div");
			if (switch_instance) create_component(switch_instance.$$.fragment);
			attr_dev(div, "class", "selectedItem svelte-1gdq94k");
			add_location(div, file$1, 861, 4, 21729);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (switch_instance) {
				mount_component(switch_instance, div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "focus", /*handleFocus*/ ctx[32], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const switch_instance_changes = {};
			if (dirty[0] & /*selectedValue*/ 1) switch_instance_changes.item = /*selectedValue*/ ctx[0];
			if (dirty[0] & /*getSelectionLabel*/ 8192) switch_instance_changes.getSelectionLabel = /*getSelectionLabel*/ ctx[13];

			if (switch_value !== (switch_value = /*Selection*/ ctx[6])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, div, null);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (switch_instance) destroy_component(switch_instance);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(861:2) {#if !isMulti && showSelectedItem}",
		ctx
	});

	return block;
}

// (870:2) {#if showSelectedItem && isClearable && !isDisabled && !isWaiting}
function create_if_block_3(ctx) {
	let div;
	let switch_instance;
	let current;
	let mounted;
	let dispose;
	var switch_value = /*ClearIcon*/ ctx[23];

	function switch_props(ctx) {
		return { $$inline: true };
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props());
	}

	const block = {
		c: function create() {
			div = element("div");
			if (switch_instance) create_component(switch_instance.$$.fragment);
			attr_dev(div, "class", "clearSelect svelte-1gdq94k");
			add_location(div, file$1, 870, 4, 21981);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (switch_instance) {
				mount_component(switch_instance, div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", prevent_default(/*handleClear*/ ctx[24]), false, true, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (switch_value !== (switch_value = /*ClearIcon*/ ctx[23])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props());
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, div, null);
				} else {
					switch_instance = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (switch_instance) destroy_component(switch_instance);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(870:2) {#if showSelectedItem && isClearable && !isDisabled && !isWaiting}",
		ctx
	});

	return block;
}

// (876:2) {#if showIndicator || (showChevron && !selectedValue || (!isSearchable && !isDisabled && !isWaiting && ((showSelectedItem && !isClearable) || !showSelectedItem)))}
function create_if_block_1$1(ctx) {
	let div;

	function select_block_type_1(ctx, dirty) {
		if (/*indicatorSvg*/ ctx[22]) return create_if_block_2$1;
		return create_else_block$1;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if_block.c();
			attr_dev(div, "class", "indicator svelte-1gdq94k");
			add_location(div, file$1, 876, 4, 22280);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_block.m(div, null);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(876:2) {#if showIndicator || (showChevron && !selectedValue || (!isSearchable && !isDisabled && !isWaiting && ((showSelectedItem && !isClearable) || !showSelectedItem)))}",
		ctx
	});

	return block;
}

// (880:6) {:else}
function create_else_block$1(ctx) {
	let svg;
	let path;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747\n            3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0\n            1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502\n            0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0\n            0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z");
			add_location(path, file$1, 885, 10, 22501);
			attr_dev(svg, "width", "100%");
			attr_dev(svg, "height", "100%");
			attr_dev(svg, "viewBox", "0 0 20 20");
			attr_dev(svg, "focusable", "false");
			attr_dev(svg, "class", "svelte-1gdq94k");
			add_location(svg, file$1, 880, 8, 22380);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(880:6) {:else}",
		ctx
	});

	return block;
}

// (878:6) {#if indicatorSvg}
function create_if_block_2$1(ctx) {
	let html_tag;
	let html_anchor;

	const block = {
		c: function create() {
			html_tag = new HtmlTag();
			html_anchor = empty();
			html_tag.a = html_anchor;
		},
		m: function mount(target, anchor) {
			html_tag.m(/*indicatorSvg*/ ctx[22], target, anchor);
			insert_dev(target, html_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*indicatorSvg*/ 4194304) html_tag.p(/*indicatorSvg*/ ctx[22]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(html_anchor);
			if (detaching) html_tag.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(878:6) {#if indicatorSvg}",
		ctx
	});

	return block;
}

// (897:2) {#if isWaiting}
function create_if_block$1(ctx) {
	let div;
	let svg;
	let circle;

	const block = {
		c: function create() {
			div = element("div");
			svg = svg_element("svg");
			circle = svg_element("circle");
			attr_dev(circle, "class", "spinner_path svelte-1gdq94k");
			attr_dev(circle, "cx", "50");
			attr_dev(circle, "cy", "50");
			attr_dev(circle, "r", "20");
			attr_dev(circle, "fill", "none");
			attr_dev(circle, "stroke", "currentColor");
			attr_dev(circle, "stroke-width", "5");
			attr_dev(circle, "stroke-miterlimit", "10");
			add_location(circle, file$1, 899, 8, 23006);
			attr_dev(svg, "class", "spinner_icon svelte-1gdq94k");
			attr_dev(svg, "viewBox", "25 25 50 50");
			add_location(svg, file$1, 898, 6, 22949);
			attr_dev(div, "class", "spinner svelte-1gdq94k");
			add_location(div, file$1, 897, 4, 22921);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, svg);
			append_dev(svg, circle);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(897:2) {#if isWaiting}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let div_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*Icon*/ ctx[17] && create_if_block_7(ctx);
	let if_block1 = /*isMulti*/ ctx[8] && /*selectedValue*/ ctx[0] && /*selectedValue*/ ctx[0].length > 0 && create_if_block_6(ctx);

	function select_block_type(ctx, dirty) {
		if (/*isDisabled*/ ctx[10]) return create_if_block_5;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block2 = current_block_type(ctx);
	let if_block3 = !/*isMulti*/ ctx[8] && /*showSelectedItem*/ ctx[28] && create_if_block_4(ctx);
	let if_block4 = /*showSelectedItem*/ ctx[28] && /*isClearable*/ ctx[16] && !/*isDisabled*/ ctx[10] && !/*isWaiting*/ ctx[5] && create_if_block_3(ctx);
	let if_block5 = (/*showIndicator*/ ctx[20] || (/*showChevron*/ ctx[19] && !/*selectedValue*/ ctx[0] || !/*isSearchable*/ ctx[14] && !/*isDisabled*/ ctx[10] && !/*isWaiting*/ ctx[5] && (/*showSelectedItem*/ ctx[28] && !/*isClearable*/ ctx[16] || !/*showSelectedItem*/ ctx[28]))) && create_if_block_1$1(ctx);
	let if_block6 = /*isWaiting*/ ctx[5] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			t3 = space();
			if (if_block4) if_block4.c();
			t4 = space();
			if (if_block5) if_block5.c();
			t5 = space();
			if (if_block6) if_block6.c();
			attr_dev(div, "class", div_class_value = "selectContainer " + /*containerClasses*/ ctx[21] + " svelte-1gdq94k");
			attr_dev(div, "style", /*containerStyles*/ ctx[12]);
			toggle_class(div, "hasError", /*hasError*/ ctx[11]);
			toggle_class(div, "multiSelect", /*isMulti*/ ctx[8]);
			toggle_class(div, "disabled", /*isDisabled*/ ctx[10]);
			toggle_class(div, "focused", /*isFocused*/ ctx[4]);
			add_location(div, file$1, 815, 0, 20630);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t1);
			if_block2.m(div, null);
			append_dev(div, t2);
			if (if_block3) if_block3.m(div, null);
			append_dev(div, t3);
			if (if_block4) if_block4.m(div, null);
			append_dev(div, t4);
			if (if_block5) if_block5.m(div, null);
			append_dev(div, t5);
			if (if_block6) if_block6.m(div, null);
			/*div_binding*/ ctx[65](div);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(window, "click", /*handleWindowClick*/ ctx[33], false, false, false),
					listen_dev(window, "keydown", /*handleKeyDown*/ ctx[31], false, false, false),
					listen_dev(window, "resize", /*getPosition*/ ctx[30], false, false, false),
					listen_dev(div, "click", /*handleClick*/ ctx[34], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*Icon*/ ctx[17]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*Icon*/ 131072) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_7(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*isMulti*/ ctx[8] && /*selectedValue*/ ctx[0] && /*selectedValue*/ ctx[0].length > 0) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*isMulti, selectedValue*/ 257) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_6(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block2) {
				if_block2.p(ctx, dirty);
			} else {
				if_block2.d(1);
				if_block2 = current_block_type(ctx);

				if (if_block2) {
					if_block2.c();
					if_block2.m(div, t2);
				}
			}

			if (!/*isMulti*/ ctx[8] && /*showSelectedItem*/ ctx[28]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[0] & /*isMulti, showSelectedItem*/ 268435712) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_4(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div, t3);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*showSelectedItem*/ ctx[28] && /*isClearable*/ ctx[16] && !/*isDisabled*/ ctx[10] && !/*isWaiting*/ ctx[5]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[0] & /*showSelectedItem, isClearable, isDisabled, isWaiting*/ 268502048) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_3(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(div, t4);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (/*showIndicator*/ ctx[20] || (/*showChevron*/ ctx[19] && !/*selectedValue*/ ctx[0] || !/*isSearchable*/ ctx[14] && !/*isDisabled*/ ctx[10] && !/*isWaiting*/ ctx[5] && (/*showSelectedItem*/ ctx[28] && !/*isClearable*/ ctx[16] || !/*showSelectedItem*/ ctx[28]))) {
				if (if_block5) {
					if_block5.p(ctx, dirty);
				} else {
					if_block5 = create_if_block_1$1(ctx);
					if_block5.c();
					if_block5.m(div, t5);
				}
			} else if (if_block5) {
				if_block5.d(1);
				if_block5 = null;
			}

			if (/*isWaiting*/ ctx[5]) {
				if (if_block6) ; else {
					if_block6 = create_if_block$1(ctx);
					if_block6.c();
					if_block6.m(div, null);
				}
			} else if (if_block6) {
				if_block6.d(1);
				if_block6 = null;
			}

			if (!current || dirty[0] & /*containerClasses*/ 2097152 && div_class_value !== (div_class_value = "selectContainer " + /*containerClasses*/ ctx[21] + " svelte-1gdq94k")) {
				attr_dev(div, "class", div_class_value);
			}

			if (!current || dirty[0] & /*containerStyles*/ 4096) {
				attr_dev(div, "style", /*containerStyles*/ ctx[12]);
			}

			if (dirty[0] & /*containerClasses, hasError*/ 2099200) {
				toggle_class(div, "hasError", /*hasError*/ ctx[11]);
			}

			if (dirty[0] & /*containerClasses, isMulti*/ 2097408) {
				toggle_class(div, "multiSelect", /*isMulti*/ ctx[8]);
			}

			if (dirty[0] & /*containerClasses, isDisabled*/ 2098176) {
				toggle_class(div, "disabled", /*isDisabled*/ ctx[10]);
			}

			if (dirty[0] & /*containerClasses, isFocused*/ 2097168) {
				toggle_class(div, "focused", /*isFocused*/ ctx[4]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block3);
			transition_in(if_block4);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block3);
			transition_out(if_block4);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			if (if_block6) if_block6.d();
			/*div_binding*/ ctx[65](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let disabled;
	let showSelectedItem;
	let placeholderText;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Select', slots, []);
	const dispatch = createEventDispatcher();
	let { container = undefined } = $$props;
	let { input = undefined } = $$props;
	let { Item: Item$1 = Item } = $$props;
	let { Selection: Selection$1 = Selection } = $$props;
	let { MultiSelection: MultiSelection$1 = MultiSelection } = $$props;
	let { isMulti = false } = $$props;
	let { multiFullItemClearable = false } = $$props;
	let { isDisabled = false } = $$props;
	let { isCreatable = false } = $$props;
	let { isFocused = false } = $$props;
	let { selectedValue = undefined } = $$props;
	let { filterText = "" } = $$props;
	let { placeholder = "Select..." } = $$props;
	let { items = [] } = $$props;
	let { itemFilter = (label, filterText, option) => label.toLowerCase().includes(filterText.toLowerCase()) } = $$props;
	let { groupBy = undefined } = $$props;
	let { groupFilter = groups => groups } = $$props;
	let { isGroupHeaderSelectable = false } = $$props;

	let { getGroupHeaderLabel = option => {
		return option.label;
	} } = $$props;

	let { getOptionLabel = (option, filterText) => {
		return option.isCreator
		? `Create \"${filterText}\"`
		: option.label;
	} } = $$props;

	let { optionIdentifier = "value" } = $$props;
	let { loadOptions = undefined } = $$props;
	let { hasError = false } = $$props;
	let { containerStyles = "" } = $$props;

	let { getSelectionLabel = option => {
		if (option) return option.label;
	} } = $$props;

	let { createGroupHeaderItem = groupValue => {
		return { value: groupValue, label: groupValue };
	} } = $$props;

	let { createItem = filterText => {
		return { value: filterText, label: filterText };
	} } = $$props;

	let { isSearchable = true } = $$props;
	let { inputStyles = "" } = $$props;
	let { isClearable = true } = $$props;
	let { isWaiting = false } = $$props;
	let { listPlacement = "auto" } = $$props;
	let { listOpen = false } = $$props;
	let { list = undefined } = $$props;
	let { isVirtualList = false } = $$props;
	let { loadOptionsInterval = 300 } = $$props;
	let { noOptionsMessage = "No options" } = $$props;
	let { hideEmptyState = false } = $$props;
	let { filteredItems = [] } = $$props;
	let { inputAttributes = {} } = $$props;
	let { listAutoWidth = true } = $$props;
	let { itemHeight = 40 } = $$props;
	let { Icon = undefined } = $$props;
	let { iconProps = {} } = $$props;
	let { showChevron = false } = $$props;
	let { showIndicator = false } = $$props;
	let { containerClasses = "" } = $$props;
	let { indicatorSvg = undefined } = $$props;
	let { ClearIcon: ClearIcon$1 = ClearIcon } = $$props;
	let target;
	let activeSelectedValue;
	let _items = [];
	let originalItemsClone;
	let prev_selectedValue;
	let prev_listOpen;
	let prev_filterText;
	let prev_isFocused;
	let prev_filteredItems;

	async function resetFilter() {
		await tick();
		$$invalidate(1, filterText = "");
	}

	let getItemsHasInvoked = false;

	const getItems = debounce(
		async () => {
			getItemsHasInvoked = true;
			$$invalidate(5, isWaiting = true);

			let res = await loadOptions(filterText).catch(err => {
				console.warn('svelte-select loadOptions error :>> ', err);
				dispatch("error", { type: 'loadOptions', details: err });
			});

			if (res && !res.cancelled) {
				if (res) {
					$$invalidate(35, items = [...res]);
					dispatch("loaded", { items });
				} else {
					$$invalidate(35, items = []);
				}

				$$invalidate(5, isWaiting = false);
				$$invalidate(4, isFocused = true);
				$$invalidate(37, listOpen = true);
			}
		},
		loadOptionsInterval
	);

	let _inputAttributes = {};

	beforeUpdate(() => {
		if (isMulti && selectedValue && selectedValue.length > 1) {
			checkSelectedValueForDuplicates();
		}

		if (!isMulti && selectedValue && prev_selectedValue !== selectedValue) {
			if (!prev_selectedValue || JSON.stringify(selectedValue[optionIdentifier]) !== JSON.stringify(prev_selectedValue[optionIdentifier])) {
				dispatch("select", selectedValue);
			}
		}

		if (isMulti && JSON.stringify(selectedValue) !== JSON.stringify(prev_selectedValue)) {
			if (checkSelectedValueForDuplicates()) {
				dispatch("select", selectedValue);
			}
		}

		if (container && listOpen !== prev_listOpen) {
			if (listOpen) {
				loadList();
			} else {
				removeList();
			}
		}

		if (filterText !== prev_filterText) {
			if (filterText.length > 0) {
				$$invalidate(4, isFocused = true);
				$$invalidate(37, listOpen = true);

				if (loadOptions) {
					getItems();
				} else {
					loadList();
					$$invalidate(37, listOpen = true);

					if (isMulti) {
						$$invalidate(25, activeSelectedValue = undefined);
					}
				}
			} else {
				setList([]);
			}

			if (list) {
				list.$set({ filterText });
			}
		}

		if (isFocused !== prev_isFocused) {
			if (isFocused || listOpen) {
				handleFocus();
			} else {
				resetFilter();
				if (input) input.blur();
			}
		}

		if (prev_filteredItems !== filteredItems) {
			let _filteredItems = [...filteredItems];

			if (isCreatable && filterText) {
				const itemToCreate = createItem(filterText);
				itemToCreate.isCreator = true;

				const existingItemWithFilterValue = _filteredItems.find(item => {
					return item[optionIdentifier] === itemToCreate[optionIdentifier];
				});

				let existingSelectionWithFilterValue;

				if (selectedValue) {
					if (isMulti) {
						existingSelectionWithFilterValue = selectedValue.find(selection => {
							return selection[optionIdentifier] === itemToCreate[optionIdentifier];
						});
					} else if (selectedValue[optionIdentifier] === itemToCreate[optionIdentifier]) {
						existingSelectionWithFilterValue = selectedValue;
					}
				}

				if (!existingItemWithFilterValue && !existingSelectionWithFilterValue) {
					_filteredItems = [..._filteredItems, itemToCreate];
				}
			}

			setList(_filteredItems);
		}

		prev_selectedValue = selectedValue;
		prev_listOpen = listOpen;
		prev_filterText = filterText;
		prev_isFocused = isFocused;
		prev_filteredItems = filteredItems;
	});

	function checkSelectedValueForDuplicates() {
		let noDuplicates = true;

		if (selectedValue) {
			const ids = [];
			const uniqueValues = [];

			selectedValue.forEach(val => {
				if (!ids.includes(val[optionIdentifier])) {
					ids.push(val[optionIdentifier]);
					uniqueValues.push(val);
				} else {
					noDuplicates = false;
				}
			});

			if (!noDuplicates) $$invalidate(0, selectedValue = uniqueValues);
		}

		return noDuplicates;
	}

	function findItem(selection) {
		let matchTo = selection
		? selection[optionIdentifier]
		: selectedValue[optionIdentifier];

		return items.find(item => item[optionIdentifier] === matchTo);
	}

	function updateSelectedValueDisplay(items) {
		if (!items || items.length === 0 || items.some(item => typeof item !== "object")) return;

		if (!selectedValue || (isMulti
		? selectedValue.some(selection => !selection || !selection[optionIdentifier])
		: !selectedValue[optionIdentifier])) return;

		if (Array.isArray(selectedValue)) {
			$$invalidate(0, selectedValue = selectedValue.map(selection => findItem(selection) || selection));
		} else {
			$$invalidate(0, selectedValue = findItem() || selectedValue);
		}
	}

	async function setList(items) {
		await tick();
		if (!listOpen) return;
		if (list) return list.$set({ items });
		if (loadOptions && getItemsHasInvoked && items.length > 0) loadList();
	}

	function handleMultiItemClear(event) {
		const { detail } = event;
		const itemToRemove = selectedValue[detail ? detail.i : selectedValue.length - 1];

		if (selectedValue.length === 1) {
			$$invalidate(0, selectedValue = undefined);
		} else {
			$$invalidate(0, selectedValue = selectedValue.filter(item => {
				return item !== itemToRemove;
			}));
		}

		dispatch("clear", itemToRemove);
		getPosition();
	}

	async function getPosition() {
		await tick();
		if (!target || !container) return;
		const { top, height, width } = container.getBoundingClientRect();
		target.style["min-width"] = `${width}px`;
		target.style.width = `${listAutoWidth ? "auto" : "100%"}`;
		target.style.left = "0";

		if (listPlacement === "top") {
			target.style.bottom = `${height + 5}px`;
		} else {
			target.style.top = `${height + 5}px`;
		}

		target = target;

		if (listPlacement === "auto" && isOutOfViewport(target).bottom) {
			target.style.top = ``;
			target.style.bottom = `${height + 5}px`;
		}

		target.style.visibility = "";
	}

	function handleKeyDown(e) {
		if (!isFocused) return;

		switch (e.key) {
			case "ArrowDown":
				e.preventDefault();
				$$invalidate(37, listOpen = true);
				$$invalidate(25, activeSelectedValue = undefined);
				break;
			case "ArrowUp":
				e.preventDefault();
				$$invalidate(37, listOpen = true);
				$$invalidate(25, activeSelectedValue = undefined);
				break;
			case "Tab":
				if (!listOpen) $$invalidate(4, isFocused = false);
				break;
			case "Backspace":
				if (!isMulti || filterText.length > 0) return;
				if (isMulti && selectedValue && selectedValue.length > 0) {
					handleMultiItemClear(activeSelectedValue !== undefined
					? activeSelectedValue
					: selectedValue.length - 1);

					if (activeSelectedValue === 0 || activeSelectedValue === undefined) break;

					$$invalidate(25, activeSelectedValue = selectedValue.length > activeSelectedValue
					? activeSelectedValue - 1
					: undefined);
				}
				break;
			case "ArrowLeft":
				if (list) list.$set({ hoverItemIndex: -1 });
				if (!isMulti || filterText.length > 0) return;
				if (activeSelectedValue === undefined) {
					$$invalidate(25, activeSelectedValue = selectedValue.length - 1);
				} else if (selectedValue.length > activeSelectedValue && activeSelectedValue !== 0) {
					$$invalidate(25, activeSelectedValue -= 1);
				}
				break;
			case "ArrowRight":
				if (list) list.$set({ hoverItemIndex: -1 });
				if (!isMulti || filterText.length > 0 || activeSelectedValue === undefined) return;
				if (activeSelectedValue === selectedValue.length - 1) {
					$$invalidate(25, activeSelectedValue = undefined);
				} else if (activeSelectedValue < selectedValue.length - 1) {
					$$invalidate(25, activeSelectedValue += 1);
				}
				break;
		}
	}

	function handleFocus() {
		$$invalidate(4, isFocused = true);
		if (input) input.focus();
	}

	function removeList() {
		resetFilter();
		$$invalidate(25, activeSelectedValue = undefined);
		if (!list) return;
		list.$destroy();
		$$invalidate(36, list = undefined);
		if (!target) return;
		if (target.parentNode) target.parentNode.removeChild(target);
		target = undefined;
		$$invalidate(36, list);
		target = target;
	}

	function handleWindowClick(event) {
		if (!container) return;

		const eventTarget = event.path && event.path.length > 0
		? event.path[0]
		: event.target;

		if (container.contains(eventTarget)) return;
		$$invalidate(4, isFocused = false);
		$$invalidate(37, listOpen = false);
		$$invalidate(25, activeSelectedValue = undefined);
		if (input) input.blur();
	}

	function handleClick() {
		if (isDisabled) return;
		$$invalidate(4, isFocused = true);
		$$invalidate(37, listOpen = !listOpen);
	}

	function handleClear() {
		$$invalidate(0, selectedValue = undefined);
		$$invalidate(37, listOpen = false);
		dispatch("clear", selectedValue);
		handleFocus();
	}

	async function loadList() {
		await tick();
		if (target && list) return;

		const data = {
			Item: Item$1,
			filterText,
			optionIdentifier,
			noOptionsMessage,
			hideEmptyState,
			isVirtualList,
			selectedValue,
			isMulti,
			getGroupHeaderLabel,
			items: filteredItems,
			itemHeight
		};

		if (getOptionLabel) {
			data.getOptionLabel = getOptionLabel;
		}

		target = document.createElement("div");

		Object.assign(target.style, {
			position: "absolute",
			"z-index": 2,
			visibility: "hidden"
		});

		$$invalidate(36, list);
		target = target;
		if (container) container.appendChild(target);
		$$invalidate(36, list = new List({ target, props: data }));

		list.$on("itemSelected", event => {
			const { detail } = event;

			if (detail) {
				const item = Object.assign({}, detail);

				if (!item.isGroupHeader || item.isSelectable) {
					if (isMulti) {
						$$invalidate(0, selectedValue = selectedValue ? selectedValue.concat([item]) : [item]);
					} else {
						$$invalidate(0, selectedValue = item);
					}

					resetFilter();
					(($$invalidate(0, selectedValue), $$invalidate(48, optionIdentifier)), $$invalidate(8, isMulti));

					setTimeout(() => {
						$$invalidate(37, listOpen = false);
						$$invalidate(25, activeSelectedValue = undefined);
					});
				}
			}
		});

		list.$on("itemCreated", event => {
			const { detail } = event;

			if (isMulti) {
				$$invalidate(0, selectedValue = selectedValue || []);
				$$invalidate(0, selectedValue = [...selectedValue, createItem(detail)]);
			} else {
				$$invalidate(0, selectedValue = createItem(detail));
			}

			dispatch('itemCreated', detail);
			$$invalidate(1, filterText = "");
			$$invalidate(37, listOpen = false);
			$$invalidate(25, activeSelectedValue = undefined);
			resetFilter();
		});

		list.$on("closeList", () => {
			$$invalidate(37, listOpen = false);
		});

		($$invalidate(36, list), target = target);
		getPosition();
	}

	onMount(() => {
		if (isFocused) input.focus();
		if (listOpen) loadList();

		if (items && items.length > 0) {
			$$invalidate(60, originalItemsClone = JSON.stringify(items));
		}
	});

	onDestroy(() => {
		removeList();
	});

	const writable_props = [
		'container',
		'input',
		'Item',
		'Selection',
		'MultiSelection',
		'isMulti',
		'multiFullItemClearable',
		'isDisabled',
		'isCreatable',
		'isFocused',
		'selectedValue',
		'filterText',
		'placeholder',
		'items',
		'itemFilter',
		'groupBy',
		'groupFilter',
		'isGroupHeaderSelectable',
		'getGroupHeaderLabel',
		'getOptionLabel',
		'optionIdentifier',
		'loadOptions',
		'hasError',
		'containerStyles',
		'getSelectionLabel',
		'createGroupHeaderItem',
		'createItem',
		'isSearchable',
		'inputStyles',
		'isClearable',
		'isWaiting',
		'listPlacement',
		'listOpen',
		'list',
		'isVirtualList',
		'loadOptionsInterval',
		'noOptionsMessage',
		'hideEmptyState',
		'filteredItems',
		'inputAttributes',
		'listAutoWidth',
		'itemHeight',
		'Icon',
		'iconProps',
		'showChevron',
		'showIndicator',
		'containerClasses',
		'indicatorSvg',
		'ClearIcon'
	];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Select> was created with unknown prop '${key}'`);
	});

	function input_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			input = $$value;
			$$invalidate(3, input);
		});
	}

	function input_1_input_handler() {
		filterText = this.value;
		$$invalidate(1, filterText);
	}

	function input_1_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			input = $$value;
			$$invalidate(3, input);
		});
	}

	function input_1_input_handler_1() {
		filterText = this.value;
		$$invalidate(1, filterText);
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			container = $$value;
			$$invalidate(2, container);
		});
	}

	$$self.$$set = $$props => {
		if ('container' in $$props) $$invalidate(2, container = $$props.container);
		if ('input' in $$props) $$invalidate(3, input = $$props.input);
		if ('Item' in $$props) $$invalidate(39, Item$1 = $$props.Item);
		if ('Selection' in $$props) $$invalidate(6, Selection$1 = $$props.Selection);
		if ('MultiSelection' in $$props) $$invalidate(7, MultiSelection$1 = $$props.MultiSelection);
		if ('isMulti' in $$props) $$invalidate(8, isMulti = $$props.isMulti);
		if ('multiFullItemClearable' in $$props) $$invalidate(9, multiFullItemClearable = $$props.multiFullItemClearable);
		if ('isDisabled' in $$props) $$invalidate(10, isDisabled = $$props.isDisabled);
		if ('isCreatable' in $$props) $$invalidate(40, isCreatable = $$props.isCreatable);
		if ('isFocused' in $$props) $$invalidate(4, isFocused = $$props.isFocused);
		if ('selectedValue' in $$props) $$invalidate(0, selectedValue = $$props.selectedValue);
		if ('filterText' in $$props) $$invalidate(1, filterText = $$props.filterText);
		if ('placeholder' in $$props) $$invalidate(41, placeholder = $$props.placeholder);
		if ('items' in $$props) $$invalidate(35, items = $$props.items);
		if ('itemFilter' in $$props) $$invalidate(42, itemFilter = $$props.itemFilter);
		if ('groupBy' in $$props) $$invalidate(43, groupBy = $$props.groupBy);
		if ('groupFilter' in $$props) $$invalidate(44, groupFilter = $$props.groupFilter);
		if ('isGroupHeaderSelectable' in $$props) $$invalidate(45, isGroupHeaderSelectable = $$props.isGroupHeaderSelectable);
		if ('getGroupHeaderLabel' in $$props) $$invalidate(46, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
		if ('getOptionLabel' in $$props) $$invalidate(47, getOptionLabel = $$props.getOptionLabel);
		if ('optionIdentifier' in $$props) $$invalidate(48, optionIdentifier = $$props.optionIdentifier);
		if ('loadOptions' in $$props) $$invalidate(49, loadOptions = $$props.loadOptions);
		if ('hasError' in $$props) $$invalidate(11, hasError = $$props.hasError);
		if ('containerStyles' in $$props) $$invalidate(12, containerStyles = $$props.containerStyles);
		if ('getSelectionLabel' in $$props) $$invalidate(13, getSelectionLabel = $$props.getSelectionLabel);
		if ('createGroupHeaderItem' in $$props) $$invalidate(50, createGroupHeaderItem = $$props.createGroupHeaderItem);
		if ('createItem' in $$props) $$invalidate(51, createItem = $$props.createItem);
		if ('isSearchable' in $$props) $$invalidate(14, isSearchable = $$props.isSearchable);
		if ('inputStyles' in $$props) $$invalidate(15, inputStyles = $$props.inputStyles);
		if ('isClearable' in $$props) $$invalidate(16, isClearable = $$props.isClearable);
		if ('isWaiting' in $$props) $$invalidate(5, isWaiting = $$props.isWaiting);
		if ('listPlacement' in $$props) $$invalidate(52, listPlacement = $$props.listPlacement);
		if ('listOpen' in $$props) $$invalidate(37, listOpen = $$props.listOpen);
		if ('list' in $$props) $$invalidate(36, list = $$props.list);
		if ('isVirtualList' in $$props) $$invalidate(53, isVirtualList = $$props.isVirtualList);
		if ('loadOptionsInterval' in $$props) $$invalidate(54, loadOptionsInterval = $$props.loadOptionsInterval);
		if ('noOptionsMessage' in $$props) $$invalidate(55, noOptionsMessage = $$props.noOptionsMessage);
		if ('hideEmptyState' in $$props) $$invalidate(56, hideEmptyState = $$props.hideEmptyState);
		if ('filteredItems' in $$props) $$invalidate(38, filteredItems = $$props.filteredItems);
		if ('inputAttributes' in $$props) $$invalidate(57, inputAttributes = $$props.inputAttributes);
		if ('listAutoWidth' in $$props) $$invalidate(58, listAutoWidth = $$props.listAutoWidth);
		if ('itemHeight' in $$props) $$invalidate(59, itemHeight = $$props.itemHeight);
		if ('Icon' in $$props) $$invalidate(17, Icon = $$props.Icon);
		if ('iconProps' in $$props) $$invalidate(18, iconProps = $$props.iconProps);
		if ('showChevron' in $$props) $$invalidate(19, showChevron = $$props.showChevron);
		if ('showIndicator' in $$props) $$invalidate(20, showIndicator = $$props.showIndicator);
		if ('containerClasses' in $$props) $$invalidate(21, containerClasses = $$props.containerClasses);
		if ('indicatorSvg' in $$props) $$invalidate(22, indicatorSvg = $$props.indicatorSvg);
		if ('ClearIcon' in $$props) $$invalidate(23, ClearIcon$1 = $$props.ClearIcon);
	};

	$$self.$capture_state = () => ({
		beforeUpdate,
		createEventDispatcher,
		onDestroy,
		onMount,
		tick,
		List,
		ItemComponent: Item,
		SelectionComponent: Selection,
		MultiSelectionComponent: MultiSelection,
		isOutOfViewport,
		debounce,
		DefaultClearIcon: ClearIcon,
		dispatch,
		container,
		input,
		Item: Item$1,
		Selection: Selection$1,
		MultiSelection: MultiSelection$1,
		isMulti,
		multiFullItemClearable,
		isDisabled,
		isCreatable,
		isFocused,
		selectedValue,
		filterText,
		placeholder,
		items,
		itemFilter,
		groupBy,
		groupFilter,
		isGroupHeaderSelectable,
		getGroupHeaderLabel,
		getOptionLabel,
		optionIdentifier,
		loadOptions,
		hasError,
		containerStyles,
		getSelectionLabel,
		createGroupHeaderItem,
		createItem,
		isSearchable,
		inputStyles,
		isClearable,
		isWaiting,
		listPlacement,
		listOpen,
		list,
		isVirtualList,
		loadOptionsInterval,
		noOptionsMessage,
		hideEmptyState,
		filteredItems,
		inputAttributes,
		listAutoWidth,
		itemHeight,
		Icon,
		iconProps,
		showChevron,
		showIndicator,
		containerClasses,
		indicatorSvg,
		ClearIcon: ClearIcon$1,
		target,
		activeSelectedValue,
		_items,
		originalItemsClone,
		prev_selectedValue,
		prev_listOpen,
		prev_filterText,
		prev_isFocused,
		prev_filteredItems,
		resetFilter,
		getItemsHasInvoked,
		getItems,
		_inputAttributes,
		checkSelectedValueForDuplicates,
		findItem,
		updateSelectedValueDisplay,
		setList,
		handleMultiItemClear,
		getPosition,
		handleKeyDown,
		handleFocus,
		removeList,
		handleWindowClick,
		handleClick,
		handleClear,
		loadList,
		placeholderText,
		showSelectedItem,
		disabled
	});

	$$self.$inject_state = $$props => {
		if ('container' in $$props) $$invalidate(2, container = $$props.container);
		if ('input' in $$props) $$invalidate(3, input = $$props.input);
		if ('Item' in $$props) $$invalidate(39, Item$1 = $$props.Item);
		if ('Selection' in $$props) $$invalidate(6, Selection$1 = $$props.Selection);
		if ('MultiSelection' in $$props) $$invalidate(7, MultiSelection$1 = $$props.MultiSelection);
		if ('isMulti' in $$props) $$invalidate(8, isMulti = $$props.isMulti);
		if ('multiFullItemClearable' in $$props) $$invalidate(9, multiFullItemClearable = $$props.multiFullItemClearable);
		if ('isDisabled' in $$props) $$invalidate(10, isDisabled = $$props.isDisabled);
		if ('isCreatable' in $$props) $$invalidate(40, isCreatable = $$props.isCreatable);
		if ('isFocused' in $$props) $$invalidate(4, isFocused = $$props.isFocused);
		if ('selectedValue' in $$props) $$invalidate(0, selectedValue = $$props.selectedValue);
		if ('filterText' in $$props) $$invalidate(1, filterText = $$props.filterText);
		if ('placeholder' in $$props) $$invalidate(41, placeholder = $$props.placeholder);
		if ('items' in $$props) $$invalidate(35, items = $$props.items);
		if ('itemFilter' in $$props) $$invalidate(42, itemFilter = $$props.itemFilter);
		if ('groupBy' in $$props) $$invalidate(43, groupBy = $$props.groupBy);
		if ('groupFilter' in $$props) $$invalidate(44, groupFilter = $$props.groupFilter);
		if ('isGroupHeaderSelectable' in $$props) $$invalidate(45, isGroupHeaderSelectable = $$props.isGroupHeaderSelectable);
		if ('getGroupHeaderLabel' in $$props) $$invalidate(46, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
		if ('getOptionLabel' in $$props) $$invalidate(47, getOptionLabel = $$props.getOptionLabel);
		if ('optionIdentifier' in $$props) $$invalidate(48, optionIdentifier = $$props.optionIdentifier);
		if ('loadOptions' in $$props) $$invalidate(49, loadOptions = $$props.loadOptions);
		if ('hasError' in $$props) $$invalidate(11, hasError = $$props.hasError);
		if ('containerStyles' in $$props) $$invalidate(12, containerStyles = $$props.containerStyles);
		if ('getSelectionLabel' in $$props) $$invalidate(13, getSelectionLabel = $$props.getSelectionLabel);
		if ('createGroupHeaderItem' in $$props) $$invalidate(50, createGroupHeaderItem = $$props.createGroupHeaderItem);
		if ('createItem' in $$props) $$invalidate(51, createItem = $$props.createItem);
		if ('isSearchable' in $$props) $$invalidate(14, isSearchable = $$props.isSearchable);
		if ('inputStyles' in $$props) $$invalidate(15, inputStyles = $$props.inputStyles);
		if ('isClearable' in $$props) $$invalidate(16, isClearable = $$props.isClearable);
		if ('isWaiting' in $$props) $$invalidate(5, isWaiting = $$props.isWaiting);
		if ('listPlacement' in $$props) $$invalidate(52, listPlacement = $$props.listPlacement);
		if ('listOpen' in $$props) $$invalidate(37, listOpen = $$props.listOpen);
		if ('list' in $$props) $$invalidate(36, list = $$props.list);
		if ('isVirtualList' in $$props) $$invalidate(53, isVirtualList = $$props.isVirtualList);
		if ('loadOptionsInterval' in $$props) $$invalidate(54, loadOptionsInterval = $$props.loadOptionsInterval);
		if ('noOptionsMessage' in $$props) $$invalidate(55, noOptionsMessage = $$props.noOptionsMessage);
		if ('hideEmptyState' in $$props) $$invalidate(56, hideEmptyState = $$props.hideEmptyState);
		if ('filteredItems' in $$props) $$invalidate(38, filteredItems = $$props.filteredItems);
		if ('inputAttributes' in $$props) $$invalidate(57, inputAttributes = $$props.inputAttributes);
		if ('listAutoWidth' in $$props) $$invalidate(58, listAutoWidth = $$props.listAutoWidth);
		if ('itemHeight' in $$props) $$invalidate(59, itemHeight = $$props.itemHeight);
		if ('Icon' in $$props) $$invalidate(17, Icon = $$props.Icon);
		if ('iconProps' in $$props) $$invalidate(18, iconProps = $$props.iconProps);
		if ('showChevron' in $$props) $$invalidate(19, showChevron = $$props.showChevron);
		if ('showIndicator' in $$props) $$invalidate(20, showIndicator = $$props.showIndicator);
		if ('containerClasses' in $$props) $$invalidate(21, containerClasses = $$props.containerClasses);
		if ('indicatorSvg' in $$props) $$invalidate(22, indicatorSvg = $$props.indicatorSvg);
		if ('ClearIcon' in $$props) $$invalidate(23, ClearIcon$1 = $$props.ClearIcon);
		if ('target' in $$props) target = $$props.target;
		if ('activeSelectedValue' in $$props) $$invalidate(25, activeSelectedValue = $$props.activeSelectedValue);
		if ('_items' in $$props) $$invalidate(75, _items = $$props._items);
		if ('originalItemsClone' in $$props) $$invalidate(60, originalItemsClone = $$props.originalItemsClone);
		if ('prev_selectedValue' in $$props) prev_selectedValue = $$props.prev_selectedValue;
		if ('prev_listOpen' in $$props) prev_listOpen = $$props.prev_listOpen;
		if ('prev_filterText' in $$props) prev_filterText = $$props.prev_filterText;
		if ('prev_isFocused' in $$props) prev_isFocused = $$props.prev_isFocused;
		if ('prev_filteredItems' in $$props) prev_filteredItems = $$props.prev_filteredItems;
		if ('getItemsHasInvoked' in $$props) getItemsHasInvoked = $$props.getItemsHasInvoked;
		if ('_inputAttributes' in $$props) $$invalidate(26, _inputAttributes = $$props._inputAttributes);
		if ('placeholderText' in $$props) $$invalidate(27, placeholderText = $$props.placeholderText);
		if ('showSelectedItem' in $$props) $$invalidate(28, showSelectedItem = $$props.showSelectedItem);
		if ('disabled' in $$props) disabled = $$props.disabled;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*isDisabled*/ 1024) {
			disabled = isDisabled;
		}

		if ($$self.$$.dirty[1] & /*items*/ 16) {
			updateSelectedValueDisplay(items);
		}

		if ($$self.$$.dirty[0] & /*selectedValue, isMulti*/ 257 | $$self.$$.dirty[1] & /*optionIdentifier*/ 131072) {
			{
				if (typeof selectedValue === "string") {
					$$invalidate(0, selectedValue = {
						[optionIdentifier]: selectedValue,
						label: selectedValue
					});
				} else if (isMulti && Array.isArray(selectedValue) && selectedValue.length > 0) {
					$$invalidate(0, selectedValue = selectedValue.map(item => typeof item === "string"
					? { value: item, label: item }
					: item));
				}
			}
		}

		if ($$self.$$.dirty[1] & /*noOptionsMessage, list*/ 16777248) {
			{
				if (noOptionsMessage && list) list.$set({ noOptionsMessage });
			}
		}

		if ($$self.$$.dirty[0] & /*selectedValue, filterText*/ 3) {
			$$invalidate(28, showSelectedItem = selectedValue && filterText.length === 0);
		}

		if ($$self.$$.dirty[0] & /*selectedValue*/ 1 | $$self.$$.dirty[1] & /*placeholder*/ 1024) {
			$$invalidate(27, placeholderText = selectedValue ? "" : placeholder);
		}

		if ($$self.$$.dirty[0] & /*isSearchable*/ 16384 | $$self.$$.dirty[1] & /*inputAttributes*/ 67108864) {
			{
				$$invalidate(26, _inputAttributes = Object.assign(
					{
						autocomplete: "off",
						autocorrect: "off",
						spellcheck: false
					},
					inputAttributes
				));

				if (!isSearchable) {
					$$invalidate(26, _inputAttributes.readonly = true, _inputAttributes);
				}
			}
		}

		if ($$self.$$.dirty[0] & /*filterText, isMulti, selectedValue*/ 259 | $$self.$$.dirty[1] & /*items, loadOptions, originalItemsClone, optionIdentifier, itemFilter, getOptionLabel, groupBy, createGroupHeaderItem, isGroupHeaderSelectable, groupFilter*/ 537884688) {
			{
				let _filteredItems;
				let _items = items;

				if (items && items.length > 0 && typeof items[0] !== "object") {
					_items = items.map((item, index) => {
						return { index, value: item, label: item };
					});
				}

				if (loadOptions && filterText.length === 0 && originalItemsClone) {
					_filteredItems = JSON.parse(originalItemsClone);
					_items = JSON.parse(originalItemsClone);
				} else {
					_filteredItems = loadOptions
					? filterText.length === 0 ? [] : _items
					: _items.filter(item => {
							let keepItem = true;

							if (isMulti && selectedValue) {
								keepItem = !selectedValue.some(value => {
									return value[optionIdentifier] === item[optionIdentifier];
								});
							}

							if (!keepItem) return false;
							if (filterText.length < 1) return true;
							return itemFilter(getOptionLabel(item, filterText), filterText, item);
						});
				}

				if (groupBy) {
					const groupValues = [];
					const groups = {};

					_filteredItems.forEach(item => {
						const groupValue = groupBy(item);

						if (!groupValues.includes(groupValue)) {
							groupValues.push(groupValue);
							groups[groupValue] = [];

							if (groupValue) {
								groups[groupValue].push(Object.assign(createGroupHeaderItem(groupValue, item), {
									id: groupValue,
									isGroupHeader: true,
									isSelectable: isGroupHeaderSelectable
								}));
							}
						}

						groups[groupValue].push(Object.assign({ isGroupItem: !!groupValue }, item));
					});

					const sortedGroupedItems = [];

					groupFilter(groupValues).forEach(groupValue => {
						sortedGroupedItems.push(...groups[groupValue]);
					});

					$$invalidate(38, filteredItems = sortedGroupedItems);
				} else {
					$$invalidate(38, filteredItems = _filteredItems);
				}
			}
		}
	};

	return [
		selectedValue,
		filterText,
		container,
		input,
		isFocused,
		isWaiting,
		Selection$1,
		MultiSelection$1,
		isMulti,
		multiFullItemClearable,
		isDisabled,
		hasError,
		containerStyles,
		getSelectionLabel,
		isSearchable,
		inputStyles,
		isClearable,
		Icon,
		iconProps,
		showChevron,
		showIndicator,
		containerClasses,
		indicatorSvg,
		ClearIcon$1,
		handleClear,
		activeSelectedValue,
		_inputAttributes,
		placeholderText,
		showSelectedItem,
		handleMultiItemClear,
		getPosition,
		handleKeyDown,
		handleFocus,
		handleWindowClick,
		handleClick,
		items,
		list,
		listOpen,
		filteredItems,
		Item$1,
		isCreatable,
		placeholder,
		itemFilter,
		groupBy,
		groupFilter,
		isGroupHeaderSelectable,
		getGroupHeaderLabel,
		getOptionLabel,
		optionIdentifier,
		loadOptions,
		createGroupHeaderItem,
		createItem,
		listPlacement,
		isVirtualList,
		loadOptionsInterval,
		noOptionsMessage,
		hideEmptyState,
		inputAttributes,
		listAutoWidth,
		itemHeight,
		originalItemsClone,
		input_1_binding,
		input_1_input_handler,
		input_1_binding_1,
		input_1_input_handler_1,
		div_binding
	];
}

class Select extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$1,
			create_fragment$1,
			safe_not_equal,
			{
				container: 2,
				input: 3,
				Item: 39,
				Selection: 6,
				MultiSelection: 7,
				isMulti: 8,
				multiFullItemClearable: 9,
				isDisabled: 10,
				isCreatable: 40,
				isFocused: 4,
				selectedValue: 0,
				filterText: 1,
				placeholder: 41,
				items: 35,
				itemFilter: 42,
				groupBy: 43,
				groupFilter: 44,
				isGroupHeaderSelectable: 45,
				getGroupHeaderLabel: 46,
				getOptionLabel: 47,
				optionIdentifier: 48,
				loadOptions: 49,
				hasError: 11,
				containerStyles: 12,
				getSelectionLabel: 13,
				createGroupHeaderItem: 50,
				createItem: 51,
				isSearchable: 14,
				inputStyles: 15,
				isClearable: 16,
				isWaiting: 5,
				listPlacement: 52,
				listOpen: 37,
				list: 36,
				isVirtualList: 53,
				loadOptionsInterval: 54,
				noOptionsMessage: 55,
				hideEmptyState: 56,
				filteredItems: 38,
				inputAttributes: 57,
				listAutoWidth: 58,
				itemHeight: 59,
				Icon: 17,
				iconProps: 18,
				showChevron: 19,
				showIndicator: 20,
				containerClasses: 21,
				indicatorSvg: 22,
				ClearIcon: 23,
				handleClear: 24
			},
			add_css$1,
			[-1, -1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Select",
			options,
			id: create_fragment$1.name
		});
	}

	get container() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set container(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get input() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set input(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get Item() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set Item(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get Selection() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set Selection(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get MultiSelection() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set MultiSelection(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isMulti() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isMulti(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get multiFullItemClearable() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set multiFullItemClearable(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isDisabled() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isDisabled(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isCreatable() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isCreatable(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isFocused() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isFocused(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selectedValue() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selectedValue(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get filterText() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set filterText(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placeholder() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placeholder(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get items() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get itemFilter() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set itemFilter(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get groupBy() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set groupBy(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get groupFilter() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set groupFilter(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isGroupHeaderSelectable() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isGroupHeaderSelectable(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getGroupHeaderLabel() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getGroupHeaderLabel(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getOptionLabel() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getOptionLabel(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get optionIdentifier() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set optionIdentifier(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get loadOptions() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set loadOptions(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hasError() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hasError(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get containerStyles() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set containerStyles(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getSelectionLabel() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getSelectionLabel(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get createGroupHeaderItem() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set createGroupHeaderItem(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get createItem() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set createItem(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isSearchable() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isSearchable(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputStyles() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputStyles(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isClearable() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isClearable(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isWaiting() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isWaiting(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get listPlacement() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set listPlacement(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get listOpen() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set listOpen(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get list() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set list(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isVirtualList() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isVirtualList(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get loadOptionsInterval() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set loadOptionsInterval(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noOptionsMessage() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noOptionsMessage(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideEmptyState() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideEmptyState(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get filteredItems() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set filteredItems(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputAttributes() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputAttributes(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get listAutoWidth() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set listAutoWidth(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get itemHeight() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set itemHeight(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get Icon() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set Icon(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get iconProps() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set iconProps(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get showChevron() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showChevron(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get showIndicator() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showIndicator(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get containerClasses() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set containerClasses(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get indicatorSvg() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set indicatorSvg(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ClearIcon() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ClearIcon(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get handleClear() {
		return this.$$.ctx[24];
	}

	set handleClear(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/pages/index.svelte generated by Svelte v3.42.1 */
const file = "src/pages/index.svelte";

function add_css(target) {
	append_styles(target, "svelte-4c42hd", "div.container.svelte-4c42hd{padding-bottom:7.5%;margin-left:50px;margin-right:50px}div.input.svelte-4c42hd{width:65%;margin-top:5em;margin-left:auto;margin-right:auto}img.svelte-4c42hd{max-width:100%;max-height:100%;border-radius:0 0 1.25% 0}.media-item.svelte-4c42hd{width:calc(14.27% - 20px);margin-left:10px;margin-right:10px;margin-top:30px;height:100%}.provider-nest.svelte-4c42hd{background-color:#fff;margin-top:-7px}.card.svelte-4c42hd:hover{transition:transform 300ms ease-in-out;transform:scale(1.2);z-index:4}.provider-logo.svelte-4c42hd{border-radius:0 0 25% 25%;margin-bottom:-7px;margin-top:1px;margin-right:1px;width:20%;height:20%}.provider-logo-hover.svelte-4c42hd{border-radius:0 0 25% 25%;margin-right:1px;width:20%;height:20%;margin-top:1px}.provider-logo-hover.svelte-4c42hd:first-child{border-radius:0 0 25% 0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsic3JjL3BhZ2VzL2luZGV4LnN2ZWx0ZSJdfQ== */");
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	child_ctx[28] = i;
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[31] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[29] = list[i];
	child_ctx[28] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[31] = list[i];
	return child_ctx;
}

// (122:12) <TextField dense rounded outlined autofocus                        bind:value={input}                        on:input={debounceInput}>
function create_default_slot_6(ctx) {
	let t0;
	let t1;

	const block = {
		c: function create() {
			t0 = text("Search in ");
			t1 = text(/*$currentCountry*/ ctx[2]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*$currentCountry*/ 4) set_data_dev(t1, /*$currentCountry*/ ctx[2]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(122:12) <TextField dense rounded outlined autofocus                        bind:value={input}                        on:input={debounceInput}>",
		ctx
	});

	return block;
}

// (142:16) {:catch error}
function create_catch_block_1(ctx) {
	let p;
	let t0;
	let t1_value = /*error*/ ctx[37] + "";
	let t1;

	const block = {
		c: function create() {
			p = element("p");
			t0 = text("Select error! ");
			t1 = text(t1_value);
			add_location(p, file, 142, 20, 4228);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t0);
			append_dev(p, t1);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_catch_block_1.name,
		type: "catch",
		source: "(142:16) {:catch error}",
		ctx
	});

	return block;
}

// (133:16) {:then genres}
function create_then_block_1(ctx) {
	let label;
	let select;
	let updating_selectedValue;
	let current;

	function select_selectedValue_binding(value) {
		/*select_selectedValue_binding*/ ctx[15](value);
	}

	let select_props = {
		items: /*genres*/ ctx[38],
		placeholder: "Select genres...",
		isMulti: true
	};

	if (/*selectedGenres*/ ctx[0] !== void 0) {
		select_props.selectedValue = /*selectedGenres*/ ctx[0];
	}

	select = new Select({ props: select_props, $$inline: true });
	binding_callbacks.push(() => bind(select, 'selectedValue', select_selectedValue_binding));
	select.$on("select", /*debounceInput*/ ctx[10]);

	const block = {
		c: function create() {
			label = element("label");
			create_component(select.$$.fragment);
			add_location(label, file, 133, 20, 3822);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);
			mount_component(select, label, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const select_changes = {};

			if (!updating_selectedValue && dirty[0] & /*selectedGenres*/ 1) {
				updating_selectedValue = true;
				select_changes.selectedValue = /*selectedGenres*/ ctx[0];
				add_flush_callback(() => updating_selectedValue = false);
			}

			select.$set(select_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(select.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(select.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			destroy_component(select);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_then_block_1.name,
		type: "then",
		source: "(133:16) {:then genres}",
		ctx
	});

	return block;
}

// (131:38)                      <p>...loading selection</p>                 {:then genres}
function create_pending_block_1(ctx) {
	let p;

	const block = {
		c: function create() {
			p = element("p");
			p.textContent = "...loading selection";
			add_location(p, file, 131, 20, 3743);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_pending_block_1.name,
		type: "pending",
		source: "(131:38)                      <p>...loading selection</p>                 {:then genres}",
		ctx
	});

	return block;
}

// (130:12) <Col>
function create_default_slot_5(ctx) {
	let await_block_anchor;
	let current;

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: true,
		pending: create_pending_block_1,
		then: create_then_block_1,
		catch: create_catch_block_1,
		value: 38,
		error: 37,
		blocks: [,,,]
	};

	handle_promise(/*fetchGenres*/ ctx[8](), info);

	const block = {
		c: function create() {
			await_block_anchor = empty();
			info.block.c();
		},
		m: function mount(target, anchor) {
			insert_dev(target, await_block_anchor, anchor);
			info.block.m(target, info.anchor = anchor);
			info.mount = () => await_block_anchor.parentNode;
			info.anchor = await_block_anchor;
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			update_await_block_branch(info, ctx, dirty);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(info.block);
			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < 3; i += 1) {
				const block = info.blocks[i];
				transition_out(block);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(await_block_anchor);
			info.block.d(detaching);
			info.token = null;
			info = null;
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(130:12) <Col>",
		ctx
	});

	return block;
}

// (157:16) {:catch error}
function create_catch_block(ctx) {
	let p;
	let t0;
	let t1_value = /*error*/ ctx[37] + "";
	let t1;

	const block = {
		c: function create() {
			p = element("p");
			t0 = text("Select error! ");
			t1 = text(t1_value);
			add_location(p, file, 157, 20, 4805);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t0);
			append_dev(p, t1);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_catch_block.name,
		type: "catch",
		source: "(157:16) {:catch error}",
		ctx
	});

	return block;
}

// (150:16) {:then providers}
function create_then_block(ctx) {
	let select;
	let updating_selectedValue;
	let current;

	function select_selectedValue_binding_1(value) {
		/*select_selectedValue_binding_1*/ ctx[16](value);
	}

	let select_props = {
		items: /*currentProviders*/ ctx[6],
		placeholder: "Select providers...",
		isMulti: true
	};

	if (/*selectedProviders*/ ctx[1] !== void 0) {
		select_props.selectedValue = /*selectedProviders*/ ctx[1];
	}

	select = new Select({ props: select_props, $$inline: true });
	binding_callbacks.push(() => bind(select, 'selectedValue', select_selectedValue_binding_1));
	select.$on("select", /*debounceInput*/ ctx[10]);

	const block = {
		c: function create() {
			create_component(select.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(select, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const select_changes = {};
			if (dirty[0] & /*currentProviders*/ 64) select_changes.items = /*currentProviders*/ ctx[6];

			if (!updating_selectedValue && dirty[0] & /*selectedProviders*/ 2) {
				updating_selectedValue = true;
				select_changes.selectedValue = /*selectedProviders*/ ctx[1];
				add_flush_callback(() => updating_selectedValue = false);
			}

			select.$set(select_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(select.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(select.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(select, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_then_block.name,
		type: "then",
		source: "(150:16) {:then providers}",
		ctx
	});

	return block;
}

// (148:41)                      <p>...loading selection</p>                 {:then providers}
function create_pending_block(ctx) {
	let p;

	const block = {
		c: function create() {
			p = element("p");
			p.textContent = "...loading selection";
			add_location(p, file, 148, 20, 4382);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_pending_block.name,
		type: "pending",
		source: "(148:41)                      <p>...loading selection</p>                 {:then providers}",
		ctx
	});

	return block;
}

// (147:12) <Col>
function create_default_slot_4(ctx) {
	let await_block_anchor;
	let current;

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: true,
		pending: create_pending_block,
		then: create_then_block,
		catch: create_catch_block,
		value: 36,
		error: 37,
		blocks: [,,,]
	};

	handle_promise(/*fetchProviders*/ ctx[9](), info);

	const block = {
		c: function create() {
			await_block_anchor = empty();
			info.block.c();
		},
		m: function mount(target, anchor) {
			insert_dev(target, await_block_anchor, anchor);
			info.block.m(target, info.anchor = anchor);
			info.mount = () => await_block_anchor.parentNode;
			info.anchor = await_block_anchor;
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			update_await_block_branch(info, ctx, dirty);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(info.block);
			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < 3; i += 1) {
				const block = info.blocks[i];
				transition_out(block);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(await_block_anchor);
			info.block.d(detaching);
			info.token = null;
			info = null;
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(147:12) <Col>",
		ctx
	});

	return block;
}

// (129:8) <Row>
function create_default_slot_3(ctx) {
	let col0;
	let t;
	let col1;
	let current;

	col0 = new Col({
			props: {
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	col1 = new Col({
			props: {
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(col0.$$.fragment);
			t = space();
			create_component(col1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(col0, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(col1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const col0_changes = {};

			if (dirty[0] & /*selectedGenres*/ 1 | dirty[1] & /*$$scope*/ 256) {
				col0_changes.$$scope = { dirty, ctx };
			}

			col0.$set(col0_changes);
			const col1_changes = {};

			if (dirty[0] & /*currentProviders, selectedProviders*/ 66 | dirty[1] & /*$$scope*/ 256) {
				col1_changes.$$scope = { dirty, ctx };
			}

			col1.$set(col1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(col0.$$.fragment, local);
			transition_in(col1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(col0.$$.fragment, local);
			transition_out(col1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(col0, detaching);
			if (detaching) detach_dev(t);
			destroy_component(col1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(129:8) <Row>",
		ctx
	});

	return block;
}

// (163:8) {#if media.hits}
function create_if_block(ctx) {
	let div;
	let div_transition;
	let current;
	let each_value = /*media*/ ctx[7].hits;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div, "class", "d-flex flex-wrap align-content-start mt-4 mb-4 flex-grow-0 flex-shrink-0");
			add_location(div, file, 163, 12, 4931);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*showExtra, mouseEnter, mouseLeave, media, redirectTo, currentCard*/ 14512) {
				each_value = /*media*/ ctx[7].hits;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, fly, { y: 200, duration: 200 }, true);
				div_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			if (!div_transition) div_transition = create_bidirectional_transition(div, fly, { y: 200, duration: 200 }, false);
			div_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
			if (detaching && div_transition) div_transition.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(163:8) {#if media.hits}",
		ctx
	});

	return block;
}

// (196:24) {:else}
function create_else_block(ctx) {
	let card;
	let current;

	card = new Card({
			props: {
				flat: true,
				shaped: true,
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(card.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(card, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const card_changes = {};

			if (dirty[0] & /*media*/ 128 | dirty[1] & /*$$scope*/ 256) {
				card_changes.$$scope = { dirty, ctx };
			}

			card.$set(card_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(card.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(card.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(card, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(196:24) {:else}",
		ctx
	});

	return block;
}

// (171:24) {#if showExtra && index === currentCard}
function create_if_block_1(ctx) {
	let div;
	let card;
	let current;

	card = new Card({
			props: {
				flat: true,
				shaped: true,
				hover: true,
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(card.$$.fragment);
			set_style(div, "position", "absolute");
			add_location(div, file, 171, 28, 5472);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(card, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const card_changes = {};

			if (dirty[0] & /*media*/ 128 | dirty[1] & /*$$scope*/ 256) {
				card_changes.$$scope = { dirty, ctx };
			}

			card.$set(card_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(card.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(card.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(card);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(171:24) {#if showExtra && index === currentCard}",
		ctx
	});

	return block;
}

// (201:36) {#each media.specific_providers as provider}
function create_each_block_3(ctx) {
	let img;
	let img_src_value;
	let img_alt_value;

	const block = {
		c: function create() {
			img = element("img");
			attr_dev(img, "class", "provider-logo svelte-4c42hd");
			if (!src_url_equal(img.src, img_src_value = "https://image.tmdb.org/t/p/original" + /*provider*/ ctx[31].logo_path)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", img_alt_value = "Poster for " + /*media*/ ctx[7].title);
			add_location(img, file, 201, 40, 7412);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*media*/ 128 && !src_url_equal(img.src, img_src_value = "https://image.tmdb.org/t/p/original" + /*provider*/ ctx[31].logo_path)) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty[0] & /*media*/ 128 && img_alt_value !== (img_alt_value = "Poster for " + /*media*/ ctx[7].title)) {
				attr_dev(img, "alt", img_alt_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_3.name,
		type: "each",
		source: "(201:36) {#each media.specific_providers as provider}",
		ctx
	});

	return block;
}

// (197:28) <Card flat shaped>
function create_default_slot_2(ctx) {
	let img;
	let img_src_value;
	let t;
	let div;
	let each_value_3 = /*media*/ ctx[7].specific_providers;
	validate_each_argument(each_value_3);
	let each_blocks = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	}

	const block = {
		c: function create() {
			img = element("img");
			t = space();
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			if (!src_url_equal(img.src, img_src_value = "https://image.tmdb.org/t/p/w500" + /*media*/ ctx[7].poster_path)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "background");
			attr_dev(img, "class", "svelte-4c42hd");
			add_location(img, file, 197, 32, 7113);
			attr_dev(div, "class", "provider-nest svelte-4c42hd");
			add_location(div, file, 199, 32, 7263);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
			insert_dev(target, t, anchor);
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*media*/ 128 && !src_url_equal(img.src, img_src_value = "https://image.tmdb.org/t/p/w500" + /*media*/ ctx[7].poster_path)) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty[0] & /*media*/ 128) {
				each_value_3 = /*media*/ ctx[7].specific_providers;
				validate_each_argument(each_value_3);
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3(ctx, each_value_3, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_3.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(197:28) <Card flat shaped>",
		ctx
	});

	return block;
}

// (178:40) {#each media.specific_providers as provider}
function create_each_block_2(ctx) {
	let img;
	let img_src_value;
	let img_alt_value;

	const block = {
		c: function create() {
			img = element("img");
			attr_dev(img, "class", "provider-logo-hover svelte-4c42hd");
			if (!src_url_equal(img.src, img_src_value = "https://image.tmdb.org/t/p/original" + /*provider*/ ctx[31].logo_path)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", img_alt_value = "Poster for " + /*media*/ ctx[7].title);
			add_location(img, file, 178, 44, 5989);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*media*/ 128 && !src_url_equal(img.src, img_src_value = "https://image.tmdb.org/t/p/original" + /*provider*/ ctx[31].logo_path)) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty[0] & /*media*/ 128 && img_alt_value !== (img_alt_value = "Poster for " + /*media*/ ctx[7].title)) {
				attr_dev(img, "alt", img_alt_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(178:40) {#each media.specific_providers as provider}",
		ctx
	});

	return block;
}

// (188:48) {#if index !== media.genres.length - 1}
function create_if_block_2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("• ");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(188:48) {#if index !== media.genres.length - 1}",
		ctx
	});

	return block;
}

// (186:44) {#each media.genres as genre, index}
function create_each_block_1(ctx) {
	let t0_value = /*genre*/ ctx[29] + "";
	let t0;
	let t1;
	let if_block_anchor;
	let if_block = /*index*/ ctx[28] !== /*media*/ ctx[7].genres.length - 1 && create_if_block_2(ctx);

	const block = {
		c: function create() {
			t0 = text(t0_value);
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*media*/ 128 && t0_value !== (t0_value = /*genre*/ ctx[29] + "")) set_data_dev(t0, t0_value);

			if (/*index*/ ctx[28] !== /*media*/ ctx[7].genres.length - 1) {
				if (if_block) ; else {
					if_block = create_if_block_2(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(186:44) {#each media.genres as genre, index}",
		ctx
	});

	return block;
}

// (173:32) <Card flat shaped hover>
function create_default_slot_1(ctx) {
	let img;
	let img_src_value;
	let t0;
	let div;
	let t1;
	let p;
	let small;
	let t2;
	let br;
	let mounted;
	let dispose;
	let each_value_2 = /*media*/ ctx[7].specific_providers;
	validate_each_argument(each_value_2);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	let each_value_1 = /*media*/ ctx[7].genres;
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			img = element("img");
			t0 = space();
			div = element("div");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t1 = space();
			p = element("p");
			small = element("small");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			br = element("br");
			if (!src_url_equal(img.src, img_src_value = "https://image.tmdb.org/t/p/w500" + /*media*/ ctx[7].poster_path)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "background");
			attr_dev(img, "class", "svelte-4c42hd");
			add_location(img, file, 173, 36, 5599);
			attr_dev(div, "class", "provider-nest svelte-4c42hd");
			add_location(div, file, 176, 36, 5832);
			add_location(small, file, 184, 40, 6439);
			add_location(br, file, 192, 36, 6922);
			set_style(p, "margin", "5px 10px 17px 10px");
			set_style(p, "font-weight", "bold");
			add_location(p, file, 183, 36, 6341);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div, null);
			}

			insert_dev(target, t1, anchor);
			insert_dev(target, p, anchor);
			append_dev(p, small);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(small, null);
			}

			append_dev(p, t2);
			append_dev(p, br);

			if (!mounted) {
				dispose = listen_dev(
					img,
					"click",
					function () {
						if (is_function(/*redirectTo*/ ctx[13](/*media*/ ctx[7].id))) /*redirectTo*/ ctx[13](/*media*/ ctx[7].id).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*media*/ 128 && !src_url_equal(img.src, img_src_value = "https://image.tmdb.org/t/p/w500" + /*media*/ ctx[7].poster_path)) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty[0] & /*media*/ 128) {
				each_value_2 = /*media*/ ctx[7].specific_providers;
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_2(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(div, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_2.length;
			}

			if (dirty[0] & /*media*/ 128) {
				each_value_1 = /*media*/ ctx[7].genres;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(small, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			destroy_each(each_blocks_1, detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(p);
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(173:32) <Card flat shaped hover>",
		ctx
	});

	return block;
}

// (166:16) {#each media.hits as media, index}
function create_each_block(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let t;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_1, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*showExtra*/ ctx[4] && /*index*/ ctx[28] === /*currentCard*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	function mouseenter_handler() {
		return /*mouseenter_handler*/ ctx[17](/*index*/ ctx[28]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if_block.c();
			t = space();
			attr_dev(div, "class", "media-item svelte-4c42hd");
			set_style(div, "transition", "all 150ms linear");
			toggle_class(div, "card", /*showExtra*/ ctx[4]);
			add_location(div, file, 166, 20, 5151);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			append_dev(div, t);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div, "mouseenter", mouseenter_handler, false, false, false),
					listen_dev(div, "mouseleave", /*mouseLeave*/ ctx[12], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, t);
			}

			if (dirty[0] & /*showExtra*/ 16) {
				toggle_class(div, "card", /*showExtra*/ ctx[4]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_blocks[current_block_type_index].d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(166:16) {#each media.hits as media, index}",
		ctx
	});

	return block;
}

// (116:0) <MaterialApp>
function create_default_slot(ctx) {
	let header;
	let t0;
	let div1;
	let br;
	let t1;
	let h1;
	let t3;
	let div0;
	let textfield;
	let updating_value;
	let t4;
	let row;
	let t5;
	let current;
	header = new Header({ $$inline: true });

	function textfield_value_binding(value) {
		/*textfield_value_binding*/ ctx[14](value);
	}

	let textfield_props = {
		dense: true,
		rounded: true,
		outlined: true,
		autofocus: true,
		$$slots: { default: [create_default_slot_6] },
		$$scope: { ctx }
	};

	if (/*input*/ ctx[3] !== void 0) {
		textfield_props.value = /*input*/ ctx[3];
	}

	textfield = new TextField({ props: textfield_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding));
	textfield.$on("input", /*debounceInput*/ ctx[10]);

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	let if_block = /*media*/ ctx[7].hits && create_if_block(ctx);

	const block = {
		c: function create() {
			create_component(header.$$.fragment);
			t0 = space();
			div1 = element("div");
			br = element("br");
			t1 = space();
			h1 = element("h1");
			h1.textContent = "streamchaser";
			t3 = space();
			div0 = element("div");
			create_component(textfield.$$.fragment);
			t4 = space();
			create_component(row.$$.fragment);
			t5 = space();
			if (if_block) if_block.c();
			add_location(br, file, 118, 8, 3330);
			set_style(h1, "text-align", "center");
			add_location(h1, file, 119, 8, 3343);
			attr_dev(div0, "class", "input svelte-4c42hd");
			add_location(div0, file, 120, 8, 3400);
			attr_dev(div1, "class", "container svelte-4c42hd");
			add_location(div1, file, 117, 4, 3298);
		},
		m: function mount(target, anchor) {
			mount_component(header, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div1, anchor);
			append_dev(div1, br);
			append_dev(div1, t1);
			append_dev(div1, h1);
			append_dev(div1, t3);
			append_dev(div1, div0);
			mount_component(textfield, div0, null);
			append_dev(div1, t4);
			mount_component(row, div1, null);
			append_dev(div1, t5);
			if (if_block) if_block.m(div1, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const textfield_changes = {};

			if (dirty[0] & /*$currentCountry*/ 4 | dirty[1] & /*$$scope*/ 256) {
				textfield_changes.$$scope = { dirty, ctx };
			}

			if (!updating_value && dirty[0] & /*input*/ 8) {
				updating_value = true;
				textfield_changes.value = /*input*/ ctx[3];
				add_flush_callback(() => updating_value = false);
			}

			textfield.$set(textfield_changes);
			const row_changes = {};

			if (dirty[0] & /*currentProviders, selectedProviders, selectedGenres*/ 67 | dirty[1] & /*$$scope*/ 256) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);

			if (/*media*/ ctx[7].hits) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*media*/ 128) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header.$$.fragment, local);
			transition_in(textfield.$$.fragment, local);
			transition_in(row.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(header.$$.fragment, local);
			transition_out(textfield.$$.fragment, local);
			transition_out(row.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(header, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div1);
			destroy_component(textfield);
			destroy_component(row);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(116:0) <MaterialApp>",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let materialapp;
	let current;

	materialapp = new MaterialApp({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(materialapp.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(materialapp, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const materialapp_changes = {};

			if (dirty[0] & /*media, showExtra, currentCard, currentProviders, selectedProviders, selectedGenres, input, $currentCountry*/ 255 | dirty[1] & /*$$scope*/ 256) {
				materialapp_changes.$$scope = { dirty, ctx };
			}

			materialapp.$set(materialapp_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(materialapp.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(materialapp.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(materialapp, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const search_url = 'http://localhost:1337/search/';
const genre_url = 'http://localhost:1337/genres/';
const PROVIDER_URL = 'http://localhost:1337/providers/';
const INPUT_TIMER = 200;

function instance($$self, $$props, $$invalidate) {
	let $currentCountry;
	let $goto;
	validate_store(currentCountry, 'currentCountry');
	component_subscribe($$self, currentCountry, $$value => $$invalidate(2, $currentCountry = $$value));
	validate_store(goto, 'goto');
	component_subscribe($$self, goto, $$value => $$invalidate(22, $goto = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Pages', slots, []);
	let input = '';
	let timer;
	let active = false;
	let media = [];
	let showExtra = false;
	let currentCard;
	let hoverTimer;
	let selectedGenres;
	let selectedProviders;
	let bgImg;
	let currentProviders;
	let mappedSelectedGenres;
	let mappedSelectedProviders;

	const fetchGenres = async () => {
		const res = await fetch(genre_url);
		return await res.json();
	};

	const fetchProviders = async () => {
		const res = await fetch(PROVIDER_URL + $currentCountry);
		$$invalidate(6, currentProviders = await res.json());
	};

	// run search if we haven't received input in the last 200ms
	const debounceInput = () => {
		clearTimeout(timer);

		timer = setTimeout(
			() => {
				input.trim() ? search() : $$invalidate(7, media = []);
			},
			INPUT_TIMER
		);
	};

	const search = async () => {
		// Builds the optional query for genres
		// Example: "?g=Action&g=Comedy&g=Drama"
		if (input) {
			let genre_query = '';

			for (let i = 0; i < mappedSelectedGenres.length; i++) {
				genre_query += `&g=${mappedSelectedGenres[i]}`;
			}

			for (let i = 0; i < mappedSelectedProviders.length; i++) {
				genre_query += `&p=${mappedSelectedProviders[i]}`;
			}

			const res = await fetch(search_url + input + '?c=' + $currentCountry + genre_query);
			$$invalidate(7, media = await res.json());
		}
	};

	function mouseEnter(index) {
		// Sets currentCard to the card currently being hovered over,
		// and enables expansion of card with extra content
		$$invalidate(5, currentCard = index);

		clearTimeout(timer);

		timer = setTimeout(
			() => {
				if (!showExtra) {
					$$invalidate(4, showExtra = true);
				}
			},
			200
		);
	}

	function resetProviders() {
		$$invalidate(1, selectedProviders = undefined);
		mappedSelectedProviders = [];
	}

	function mouseLeave() {
		if (showExtra) {
			$$invalidate(4, showExtra = false);
		}

		$$invalidate(5, currentCard = null);

		if (active) {
			active = false;
		}
	}

	function redirectTo(id) {
		if (id[0] === 't') {
			$goto('./tv/:cc', { cc: $currentCountry, id: id.slice(1) });
		} else {
			$goto('./movie/:cc', { cc: $currentCountry, id: id.slice(1) });
		}
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Pages> was created with unknown prop '${key}'`);
	});

	function textfield_value_binding(value) {
		input = value;
		$$invalidate(3, input);
	}

	function select_selectedValue_binding(value) {
		selectedGenres = value;
		$$invalidate(0, selectedGenres);
	}

	function select_selectedValue_binding_1(value) {
		selectedProviders = value;
		$$invalidate(1, selectedProviders);
	}

	const mouseenter_handler = index => mouseEnter(index);

	$$self.$capture_state = () => ({
		fly,
		currentCountry,
		MaterialApp,
		TextField,
		Card,
		Row,
		Col,
		Select,
		Header,
		goto,
		search_url,
		genre_url,
		PROVIDER_URL,
		INPUT_TIMER,
		input,
		timer,
		active,
		media,
		showExtra,
		currentCard,
		hoverTimer,
		selectedGenres,
		selectedProviders,
		bgImg,
		currentProviders,
		mappedSelectedGenres,
		mappedSelectedProviders,
		fetchGenres,
		fetchProviders,
		debounceInput,
		search,
		mouseEnter,
		resetProviders,
		mouseLeave,
		redirectTo,
		$currentCountry,
		$goto
	});

	$$self.$inject_state = $$props => {
		if ('input' in $$props) $$invalidate(3, input = $$props.input);
		if ('timer' in $$props) timer = $$props.timer;
		if ('active' in $$props) active = $$props.active;
		if ('media' in $$props) $$invalidate(7, media = $$props.media);
		if ('showExtra' in $$props) $$invalidate(4, showExtra = $$props.showExtra);
		if ('currentCard' in $$props) $$invalidate(5, currentCard = $$props.currentCard);
		if ('hoverTimer' in $$props) hoverTimer = $$props.hoverTimer;
		if ('selectedGenres' in $$props) $$invalidate(0, selectedGenres = $$props.selectedGenres);
		if ('selectedProviders' in $$props) $$invalidate(1, selectedProviders = $$props.selectedProviders);
		if ('bgImg' in $$props) bgImg = $$props.bgImg;
		if ('currentProviders' in $$props) $$invalidate(6, currentProviders = $$props.currentProviders);
		if ('mappedSelectedGenres' in $$props) mappedSelectedGenres = $$props.mappedSelectedGenres;
		if ('mappedSelectedProviders' in $$props) mappedSelectedProviders = $$props.mappedSelectedProviders;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*selectedGenres*/ 1) {
			mappedSelectedGenres = selectedGenres
			? selectedGenres.map(item => item.value)
			: [];
		}

		if ($$self.$$.dirty[0] & /*selectedProviders*/ 2) {
			mappedSelectedProviders = selectedProviders
			? selectedProviders.map(item => item.value)
			: [];
		}

		if ($$self.$$.dirty[0] & /*$currentCountry*/ 4) {
			// If the variable changes
			if ($currentCountry) {
				resetProviders();
				fetchProviders();
				search();
			}
		}
	};

	return [
		selectedGenres,
		selectedProviders,
		$currentCountry,
		input,
		showExtra,
		currentCard,
		currentProviders,
		media,
		fetchGenres,
		fetchProviders,
		debounceInput,
		mouseEnter,
		mouseLeave,
		redirectTo,
		textfield_value_binding,
		select_selectedValue_binding,
		select_selectedValue_binding_1,
		mouseenter_handler
	];
}

class Pages extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {}, add_css, [-1, -1]);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Pages",
			options,
			id: create_fragment.name
		});
	}
}

export { Pages as default };
//# sourceMappingURL=index2.js.map
