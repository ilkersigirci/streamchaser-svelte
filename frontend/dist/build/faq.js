
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, a as append_styles, m as create_slot, b as validate_slots, _ as createEventDispatcher, $ as setContext, a0 as writable, e as element, g as attr_dev, o as toggle_class, h as add_location, j as insert_dev, q as update_slot_base, r as get_all_dirty_from_scope, w as get_slot_changes, y as transition_in, z as transition_out, l as detach_dev, a1 as getContext, v as validate_store, c as component_subscribe, A as create_component, B as mount_component, C as destroy_component, L as listen_dev, X as add_render_callback, a2 as create_bidirectional_transition, N as run_all, f as space, k as append_dev, Q as group_outros, R as check_outros, O as bubble, D as set_style, t as text } from './main.js';
import { I as Icon, M as MaterialApp, H as Header } from './Header.js';
import { s as slide } from './index.js';

var down = 'M7,10L12,15L17,10H7Z';

/* node_modules/svelte-materialify/dist/components/ExpansionPanels/ExpansionPanels.svelte generated by Svelte v3.42.1 */
const file$2 = "node_modules/svelte-materialify/dist/components/ExpansionPanels/ExpansionPanels.svelte";

function add_css$1(target) {
	append_styles(target, "svelte-1t9030l", ".s-expansion-panels{border-radius:4px;display:flex;flex:0 1 auto;position:relative;max-width:100%;transition:0.3s cubic-bezier(0.25, 0.8, 0.5, 1);flex-wrap:wrap;justify-content:center;list-style-type:none;padding:0;width:100%;z-index:1}.s-expansion-panels>:first-child{border-top-left-radius:inherit;border-top-right-radius:inherit}.s-expansion-panels>:last-child{border-bottom-left-radius:inherit;border-bottom-right-radius:inherit}.s-expansion-panels.accordion>.s-expansion-panel{margin-top:0 !important}.s-expansion-panels.accordion>.s-expansion-panel:after{opacity:1 !important}.s-expansion-panels.popout>.s-expansion-panel{max-width:calc(100% - 32px)}.s-expansion-panels.popout>.s-expansion-panel.active{max-width:calc(100% + 16px)}.s-expansion-panels.inset>.s-expansion-panel{max-width:100%}.s-expansion-panels.inset>.s-expansion-panel.active{max-width:calc(100% - 32px)}.s-expansion-panels.flat>.s-expansion-panel:after{border-top:none}.s-expansion-panels.flat>.s-expansion-panel:before{box-shadow:none}.s-expansion-panels.tile,.s-expansion-panels.tile>.s-expansion-panel:before{border-radius:0}.s-expansion-panels:not(.accordion):not(.tile)>.s-expansion-panel.active{border-radius:4px}.s-expansion-panels:not(.accordion):not(.tile)>.s-expansion-panel.active+.s-expansion-panel{border-top-left-radius:4px;border-top-right-radius:4px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRXhwYW5zaW9uUGFuZWxzLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUE4RXNELG1CQUFBLEFBQUEsQ0FBQSx3eUNBQXlqRCIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJFeHBhbnNpb25QYW5lbHMuc3ZlbHRlIl19 */");
}

function create_fragment$2(ctx) {
	let div;
	let div_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div, "class", div_class_value = "s-expansion-panels " + /*klass*/ ctx[0]);
			attr_dev(div, "style", /*style*/ ctx[6]);
			toggle_class(div, "accordion", /*accordion*/ ctx[1]);
			toggle_class(div, "popout", /*popout*/ ctx[2]);
			toggle_class(div, "inset", /*inset*/ ctx[3]);
			toggle_class(div, "flat", /*flat*/ ctx[4]);
			toggle_class(div, "tile", /*tile*/ ctx[5]);
			add_location(div, file$2, 134, 0, 3668);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[11],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*klass*/ 1 && div_class_value !== (div_class_value = "s-expansion-panels " + /*klass*/ ctx[0])) {
				attr_dev(div, "class", div_class_value);
			}

			if (!current || dirty & /*style*/ 64) {
				attr_dev(div, "style", /*style*/ ctx[6]);
			}

			if (dirty & /*klass, accordion*/ 3) {
				toggle_class(div, "accordion", /*accordion*/ ctx[1]);
			}

			if (dirty & /*klass, popout*/ 5) {
				toggle_class(div, "popout", /*popout*/ ctx[2]);
			}

			if (dirty & /*klass, inset*/ 9) {
				toggle_class(div, "inset", /*inset*/ ctx[3]);
			}

			if (dirty & /*klass, flat*/ 17) {
				toggle_class(div, "flat", /*flat*/ ctx[4]);
			}

			if (dirty & /*klass, tile*/ 33) {
				toggle_class(div, "tile", /*tile*/ ctx[5]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const EXPANSION_PANELS = {};

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ExpansionPanels', slots, ['default']);
	let { class: klass = '' } = $$props;
	let { value = [] } = $$props;
	let { multiple = false } = $$props;
	let { mandatory = false } = $$props;
	let { accordion = false } = $$props;
	let { popout = false } = $$props;
	let { inset = false } = $$props;
	let { flat = false } = $$props;
	let { tile = false } = $$props;
	let { disabled = null } = $$props;
	let { style = null } = $$props;
	const dispatch = createEventDispatcher();
	const values = writable(value);
	const Disabled = writable(disabled);
	let startIndex = -1;

	setContext(EXPANSION_PANELS, {
		values,
		Disabled,
		selectPanel: index => {
			if (value.includes(index)) {
				if (!(mandatory && value.length === 1)) {
					value.splice(value.indexOf(index), 1);
					$$invalidate(7, value);
					dispatch('change', { index, active: false });
				}
			} else {
				if (multiple) {
					value.push(index);
					$$invalidate(7, value);
				} else {
					$$invalidate(7, value = [index]);
				}

				dispatch('change', { index, active: true });
			}
		},
		index: () => {
			startIndex += 1;
			return startIndex;
		}
	});

	const writable_props = [
		'class',
		'value',
		'multiple',
		'mandatory',
		'accordion',
		'popout',
		'inset',
		'flat',
		'tile',
		'disabled',
		'style'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ExpansionPanels> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('class' in $$props) $$invalidate(0, klass = $$props.class);
		if ('value' in $$props) $$invalidate(7, value = $$props.value);
		if ('multiple' in $$props) $$invalidate(8, multiple = $$props.multiple);
		if ('mandatory' in $$props) $$invalidate(9, mandatory = $$props.mandatory);
		if ('accordion' in $$props) $$invalidate(1, accordion = $$props.accordion);
		if ('popout' in $$props) $$invalidate(2, popout = $$props.popout);
		if ('inset' in $$props) $$invalidate(3, inset = $$props.inset);
		if ('flat' in $$props) $$invalidate(4, flat = $$props.flat);
		if ('tile' in $$props) $$invalidate(5, tile = $$props.tile);
		if ('disabled' in $$props) $$invalidate(10, disabled = $$props.disabled);
		if ('style' in $$props) $$invalidate(6, style = $$props.style);
		if ('$$scope' in $$props) $$invalidate(11, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		EXPANSION_PANELS,
		createEventDispatcher,
		setContext,
		writable,
		klass,
		value,
		multiple,
		mandatory,
		accordion,
		popout,
		inset,
		flat,
		tile,
		disabled,
		style,
		dispatch,
		values,
		Disabled,
		startIndex
	});

	$$self.$inject_state = $$props => {
		if ('klass' in $$props) $$invalidate(0, klass = $$props.klass);
		if ('value' in $$props) $$invalidate(7, value = $$props.value);
		if ('multiple' in $$props) $$invalidate(8, multiple = $$props.multiple);
		if ('mandatory' in $$props) $$invalidate(9, mandatory = $$props.mandatory);
		if ('accordion' in $$props) $$invalidate(1, accordion = $$props.accordion);
		if ('popout' in $$props) $$invalidate(2, popout = $$props.popout);
		if ('inset' in $$props) $$invalidate(3, inset = $$props.inset);
		if ('flat' in $$props) $$invalidate(4, flat = $$props.flat);
		if ('tile' in $$props) $$invalidate(5, tile = $$props.tile);
		if ('disabled' in $$props) $$invalidate(10, disabled = $$props.disabled);
		if ('style' in $$props) $$invalidate(6, style = $$props.style);
		if ('startIndex' in $$props) startIndex = $$props.startIndex;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 128) {
			values.set(value);
		}

		if ($$self.$$.dirty & /*disabled*/ 1024) {
			Disabled.set(disabled);
		}
	};

	return [
		klass,
		accordion,
		popout,
		inset,
		flat,
		tile,
		style,
		value,
		multiple,
		mandatory,
		disabled,
		$$scope,
		slots
	];
}

class ExpansionPanels extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$2,
			create_fragment$2,
			safe_not_equal,
			{
				class: 0,
				value: 7,
				multiple: 8,
				mandatory: 9,
				accordion: 1,
				popout: 2,
				inset: 3,
				flat: 4,
				tile: 5,
				disabled: 10,
				style: 6
			},
			add_css$1
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ExpansionPanels",
			options,
			id: create_fragment$2.name
		});
	}

	get class() {
		throw new Error("<ExpansionPanels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<ExpansionPanels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<ExpansionPanels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<ExpansionPanels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get multiple() {
		throw new Error("<ExpansionPanels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set multiple(value) {
		throw new Error("<ExpansionPanels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mandatory() {
		throw new Error("<ExpansionPanels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mandatory(value) {
		throw new Error("<ExpansionPanels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get accordion() {
		throw new Error("<ExpansionPanels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set accordion(value) {
		throw new Error("<ExpansionPanels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get popout() {
		throw new Error("<ExpansionPanels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set popout(value) {
		throw new Error("<ExpansionPanels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inset() {
		throw new Error("<ExpansionPanels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inset(value) {
		throw new Error("<ExpansionPanels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get flat() {
		throw new Error("<ExpansionPanels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set flat(value) {
		throw new Error("<ExpansionPanels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tile() {
		throw new Error("<ExpansionPanels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tile(value) {
		throw new Error("<ExpansionPanels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<ExpansionPanels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<ExpansionPanels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<ExpansionPanels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<ExpansionPanels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/svelte-materialify/dist/components/ExpansionPanels/ExpansionPanel.svelte generated by Svelte v3.42.1 */
const file$1 = "node_modules/svelte-materialify/dist/components/ExpansionPanels/ExpansionPanel.svelte";

function add_css(target) {
	append_styles(target, "svelte-jun7hr", ".s-expansion-panel__header{align-items:center;border-top-left-radius:inherit;border-top-right-radius:inherit;display:flex;font-size:.9375rem;line-height:1;min-height:48px;outline:none;padding:16px 24px;position:relative;transition:min-height 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);width:100%;text-align:left}.s-expansion-panel__header:before{background-color:currentColor;border-radius:inherit;bottom:0;content:\"\";left:0;opacity:0;pointer-events:none;position:absolute;right:0;top:0;transition:opacity 0.3s cubic-bezier(0.25, 0.8, 0.5, 1)}.s-expansion-panel__header:hover:before{opacity:.04}.s-expansion-panel__header.focus-visible:before{opacity:.12}.s-expansion-panel{background-color:var(--theme-cards);color:var(--theme-text-primary);flex:1 0 100%;max-width:100%;position:relative;transition:0.3s cubic-bezier(0.25, 0.8, 0.5, 1)}.s-expansion-panel:not(:first-child):after{border-color:var(--theme-dividers);border-top:thin solid;border-top-color:var(--theme-dividers);content:\"\";left:0;position:absolute;right:0;top:0;transition:border-color 0.2s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1)}.s-expansion-panel:before{border-radius:inherit;bottom:0;content:\"\";left:0;position:absolute;right:0;top:0;z-index:-1;box-shadow:0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)}.s-expansion-panel.disabled{color:var(--theme-text-disabled)}.s-expansion-panel.disabled .s-expansion-panel__header,.s-expansion-panel.readonly .s-expansion-panel__header{pointer-events:none}.s-expansion-panel.active+.s-expansion-panel,.s-expansion-panel.active:not(:first-child){margin-top:16px}.s-expansion-panel.active+.s-expansion-panel:after,.s-expansion-panel.active:not(:first-child):after{opacity:0}.s-expansion-panel.active>.s-expansion-panel__header{min-height:64px}.s-expansion-panel__icon{margin-left:auto;display:inline-flex;margin-bottom:-4px;margin-top:-4px;user-select:none}.s-expansion-panel__content{display:flex;padding:0 24px 16px;flex:1 1 auto;max-width:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRXhwYW5zaW9uUGFuZWwuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXVDcUQsMEJBQUEsQUFBQSxDQUFBLG05REFBcW9FIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkV4cGFuc2lvblBhbmVsLnN2ZWx0ZSJdfQ== */");
}

const get_icon_slot_changes = dirty => ({ active: dirty & /*active*/ 32 });
const get_icon_slot_context = ctx => ({ active: /*active*/ ctx[5] });
const get_header_slot_changes = dirty => ({});
const get_header_slot_context = ctx => ({});

// (148:33)           
function fallback_block(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				disabled: /*disabled*/ ctx[0],
				path: down,
				rotate: /*active*/ ctx[5] ? 180 : 0
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*disabled*/ 1) icon_changes.disabled = /*disabled*/ ctx[0];
			if (dirty & /*active*/ 32) icon_changes.rotate = /*active*/ ctx[5] ? 180 : 0;
			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block.name,
		type: "fallback",
		source: "(148:33)           ",
		ctx
	});

	return block;
}

// (153:2) {#if active}
function create_if_block(ctx) {
	let div;
	let div_transition;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div, "class", "s-expansion-panel__content");
			add_location(div, file$1, 153, 4, 4236);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div, "introstart", /*introstart_handler*/ ctx[13], false, false, false),
					listen_dev(div, "outrostart", /*outrostart_handler*/ ctx[14], false, false, false),
					listen_dev(div, "introend", /*introend_handler*/ ctx[15], false, false, false),
					listen_dev(div, "outroend", /*outroend_handler*/ ctx[16], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[11],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
						null
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, /*slideOpts*/ ctx[2], true);
				div_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, /*slideOpts*/ ctx[2], false);
			div_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			if (detaching && div_transition) div_transition.end();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(153:2) {#if active}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div1;
	let button;
	let t0;
	let div0;
	let button_tabindex_value;
	let t1;
	let div1_class_value;
	let current;
	let mounted;
	let dispose;
	const header_slot_template = /*#slots*/ ctx[12].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[11], get_header_slot_context);
	const icon_slot_template = /*#slots*/ ctx[12].icon;
	const icon_slot = create_slot(icon_slot_template, ctx, /*$$scope*/ ctx[11], get_icon_slot_context);
	const icon_slot_or_fallback = icon_slot || fallback_block(ctx);
	let if_block = /*active*/ ctx[5] && create_if_block(ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			button = element("button");
			if (header_slot) header_slot.c();
			t0 = space();
			div0 = element("div");
			if (icon_slot_or_fallback) icon_slot_or_fallback.c();
			t1 = space();
			if (if_block) if_block.c();
			attr_dev(div0, "class", "s-expansion-panel__icon");
			add_location(div0, file$1, 145, 4, 3973);
			attr_dev(button, "type", "button");
			attr_dev(button, "class", "s-expansion-panel__header");
			attr_dev(button, "tabindex", button_tabindex_value = /*disabled*/ ctx[0] ? -1 : null);
			add_location(button, file$1, 138, 2, 3770);
			attr_dev(div1, "class", div1_class_value = "s-expansion-panel " + /*klass*/ ctx[1]);
			attr_dev(div1, "aria-expanded", /*active*/ ctx[5]);
			attr_dev(div1, "style", /*style*/ ctx[4]);
			toggle_class(div1, "active", /*active*/ ctx[5]);
			toggle_class(div1, "readonly", /*readonly*/ ctx[3]);
			toggle_class(div1, "disabled", /*disabled*/ ctx[0]);
			add_location(div1, file$1, 131, 0, 3635);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, button);

			if (header_slot) {
				header_slot.m(button, null);
			}

			append_dev(button, t0);
			append_dev(button, div0);

			if (icon_slot_or_fallback) {
				icon_slot_or_fallback.m(div0, null);
			}

			append_dev(div1, t1);
			if (if_block) if_block.m(div1, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*toggle*/ ctx[8], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (header_slot) {
				if (header_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[11],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[11], dirty, get_header_slot_changes),
						get_header_slot_context
					);
				}
			}

			if (icon_slot) {
				if (icon_slot.p && (!current || dirty & /*$$scope, active*/ 2080)) {
					update_slot_base(
						icon_slot,
						icon_slot_template,
						ctx,
						/*$$scope*/ ctx[11],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
						: get_slot_changes(icon_slot_template, /*$$scope*/ ctx[11], dirty, get_icon_slot_changes),
						get_icon_slot_context
					);
				}
			} else {
				if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & /*disabled, active*/ 33)) {
					icon_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}

			if (!current || dirty & /*disabled*/ 1 && button_tabindex_value !== (button_tabindex_value = /*disabled*/ ctx[0] ? -1 : null)) {
				attr_dev(button, "tabindex", button_tabindex_value);
			}

			if (/*active*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*active*/ 32) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty & /*klass*/ 2 && div1_class_value !== (div1_class_value = "s-expansion-panel " + /*klass*/ ctx[1])) {
				attr_dev(div1, "class", div1_class_value);
			}

			if (!current || dirty & /*active*/ 32) {
				attr_dev(div1, "aria-expanded", /*active*/ ctx[5]);
			}

			if (!current || dirty & /*style*/ 16) {
				attr_dev(div1, "style", /*style*/ ctx[4]);
			}

			if (dirty & /*klass, active*/ 34) {
				toggle_class(div1, "active", /*active*/ ctx[5]);
			}

			if (dirty & /*klass, readonly*/ 10) {
				toggle_class(div1, "readonly", /*readonly*/ ctx[3]);
			}

			if (dirty & /*klass, disabled*/ 3) {
				toggle_class(div1, "disabled", /*disabled*/ ctx[0]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			transition_in(icon_slot_or_fallback, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			transition_out(icon_slot_or_fallback, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (header_slot) header_slot.d(detaching);
			if (icon_slot_or_fallback) icon_slot_or_fallback.d(detaching);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let $values;
	let $Disabled;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ExpansionPanel', slots, ['header','icon','default']);
	const { values, Disabled, selectPanel, index } = getContext(EXPANSION_PANELS);
	validate_store(values, 'values');
	component_subscribe($$self, values, value => $$invalidate(9, $values = value));
	validate_store(Disabled, 'Disabled');
	component_subscribe($$self, Disabled, value => $$invalidate(10, $Disabled = value));
	let { class: klass = '' } = $$props;
	let { slideOpts = {} } = $$props;
	let { readonly = false } = $$props;
	let { disabled = false } = $$props;
	let { style = null } = $$props;
	const value = index();
	let active = false;

	function toggle() {
		selectPanel(value);
	}

	const writable_props = ['class', 'slideOpts', 'readonly', 'disabled', 'style'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ExpansionPanel> was created with unknown prop '${key}'`);
	});

	function introstart_handler(event) {
		bubble.call(this, $$self, event);
	}

	function outrostart_handler(event) {
		bubble.call(this, $$self, event);
	}

	function introend_handler(event) {
		bubble.call(this, $$self, event);
	}

	function outroend_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('class' in $$props) $$invalidate(1, klass = $$props.class);
		if ('slideOpts' in $$props) $$invalidate(2, slideOpts = $$props.slideOpts);
		if ('readonly' in $$props) $$invalidate(3, readonly = $$props.readonly);
		if ('disabled' in $$props) $$invalidate(0, disabled = $$props.disabled);
		if ('style' in $$props) $$invalidate(4, style = $$props.style);
		if ('$$scope' in $$props) $$invalidate(11, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		EXPANSION_PANELS,
		slide,
		Icon,
		down,
		values,
		Disabled,
		selectPanel,
		index,
		klass,
		slideOpts,
		readonly,
		disabled,
		style,
		value,
		active,
		toggle,
		$values,
		$Disabled
	});

	$$self.$inject_state = $$props => {
		if ('klass' in $$props) $$invalidate(1, klass = $$props.klass);
		if ('slideOpts' in $$props) $$invalidate(2, slideOpts = $$props.slideOpts);
		if ('readonly' in $$props) $$invalidate(3, readonly = $$props.readonly);
		if ('disabled' in $$props) $$invalidate(0, disabled = $$props.disabled);
		if ('style' in $$props) $$invalidate(4, style = $$props.style);
		if ('active' in $$props) $$invalidate(5, active = $$props.active);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$Disabled, disabled*/ 1025) {
			// Inheriting the disabled value from parent.
			$$invalidate(0, disabled = $Disabled == null ? disabled : $Disabled);
		}

		if ($$self.$$.dirty & /*$values*/ 512) {
			// Checking if panel is active everytime the value has changed.
			$$invalidate(5, active = $values.includes(value));
		}
	};

	return [
		disabled,
		klass,
		slideOpts,
		readonly,
		style,
		active,
		values,
		Disabled,
		toggle,
		$values,
		$Disabled,
		$$scope,
		slots,
		introstart_handler,
		outrostart_handler,
		introend_handler,
		outroend_handler
	];
}

class ExpansionPanel extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$1,
			create_fragment$1,
			safe_not_equal,
			{
				class: 1,
				slideOpts: 2,
				readonly: 3,
				disabled: 0,
				style: 4
			},
			add_css
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ExpansionPanel",
			options,
			id: create_fragment$1.name
		});
	}

	get class() {
		throw new Error("<ExpansionPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<ExpansionPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get slideOpts() {
		throw new Error("<ExpansionPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set slideOpts(value) {
		throw new Error("<ExpansionPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get readonly() {
		throw new Error("<ExpansionPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<ExpansionPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<ExpansionPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<ExpansionPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<ExpansionPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<ExpansionPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/pages/faq.svelte generated by Svelte v3.42.1 */
const file = "src/pages/faq.svelte";

// (17:16) <ExpansionPanel>
function create_default_slot_6(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Lorem ipsum dolor sit amet consectetur, adipisicing elit. Repellat amet natus obcaecati\r\n                    molestiae quas mollitia error modi atque aliquam esse.");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(17:16) <ExpansionPanel>",
		ctx
	});

	return block;
}

// (18:20) 
function create_header_slot_4(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Why cant I find a specific movie or tv show?";
			attr_dev(span, "slot", "header");
			add_location(span, file, 17, 20, 435);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_header_slot_4.name,
		type: "slot",
		source: "(18:20) ",
		ctx
	});

	return block;
}

// (22:16) <ExpansionPanel>
function create_default_slot_5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Lorem ipsum dolor sit amet consectetur, adipisicing elit. Repellat amet natus obcaecati\r\n                    molestiae quas mollitia error modi atque aliquam esse.");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(22:16) <ExpansionPanel>",
		ctx
	});

	return block;
}

// (23:20) 
function create_header_slot_3(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Why dont you support more countries?";
			attr_dev(span, "slot", "header");
			add_location(span, file, 22, 20, 784);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_header_slot_3.name,
		type: "slot",
		source: "(23:20) ",
		ctx
	});

	return block;
}

// (27:16) <ExpansionPanel>
function create_default_slot_4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Lorem ipsum dolor sit amet consectetur, adipisicing elit. Repellat amet natus obcaecati\r\n                    molestiae quas mollitia error modi atque aliquam esse.");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(27:16) <ExpansionPanel>",
		ctx
	});

	return block;
}

// (28:20) 
function create_header_slot_2(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "I have a good idea, how do I contact you?";
			attr_dev(span, "slot", "header");
			add_location(span, file, 27, 20, 1125);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_header_slot_2.name,
		type: "slot",
		source: "(28:20) ",
		ctx
	});

	return block;
}

// (32:16) <ExpansionPanel>
function create_default_slot_3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Lorem ipsum dolor sit amet consectetur, adipisicing elit. Repellat amet natus obcaecati\r\n                    molestiae quas mollitia error modi atque aliquam esse.");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(32:16) <ExpansionPanel>",
		ctx
	});

	return block;
}

// (33:20) 
function create_header_slot_1(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Where do you get your data from?";
			attr_dev(span, "slot", "header");
			add_location(span, file, 32, 20, 1471);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_header_slot_1.name,
		type: "slot",
		source: "(33:20) ",
		ctx
	});

	return block;
}

// (37:16) <ExpansionPanel>
function create_default_slot_2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Lorem ipsum dolor sit amet consectetur, adipisicing elit. Repellat amet natus obcaecati\r\n                    molestiae quas mollitia error modi atque aliquam esse.");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(37:16) <ExpansionPanel>",
		ctx
	});

	return block;
}

// (38:20) 
function create_header_slot(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Why are some movies or tv shows missing provider logo underneath?";
			attr_dev(span, "slot", "header");
			add_location(span, file, 37, 20, 1808);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_header_slot.name,
		type: "slot",
		source: "(38:20) ",
		ctx
	});

	return block;
}

// (16:12) <ExpansionPanels>
function create_default_slot_1(ctx) {
	let expansionpanel0;
	let t0;
	let expansionpanel1;
	let t1;
	let expansionpanel2;
	let t2;
	let expansionpanel3;
	let t3;
	let expansionpanel4;
	let current;

	expansionpanel0 = new ExpansionPanel({
			props: {
				$$slots: {
					header: [create_header_slot_4],
					default: [create_default_slot_6]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	expansionpanel1 = new ExpansionPanel({
			props: {
				$$slots: {
					header: [create_header_slot_3],
					default: [create_default_slot_5]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	expansionpanel2 = new ExpansionPanel({
			props: {
				$$slots: {
					header: [create_header_slot_2],
					default: [create_default_slot_4]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	expansionpanel3 = new ExpansionPanel({
			props: {
				$$slots: {
					header: [create_header_slot_1],
					default: [create_default_slot_3]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	expansionpanel4 = new ExpansionPanel({
			props: {
				$$slots: {
					header: [create_header_slot],
					default: [create_default_slot_2]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(expansionpanel0.$$.fragment);
			t0 = space();
			create_component(expansionpanel1.$$.fragment);
			t1 = space();
			create_component(expansionpanel2.$$.fragment);
			t2 = space();
			create_component(expansionpanel3.$$.fragment);
			t3 = space();
			create_component(expansionpanel4.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(expansionpanel0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(expansionpanel1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(expansionpanel2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(expansionpanel3, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(expansionpanel4, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const expansionpanel0_changes = {};

			if (dirty & /*$$scope*/ 1) {
				expansionpanel0_changes.$$scope = { dirty, ctx };
			}

			expansionpanel0.$set(expansionpanel0_changes);
			const expansionpanel1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				expansionpanel1_changes.$$scope = { dirty, ctx };
			}

			expansionpanel1.$set(expansionpanel1_changes);
			const expansionpanel2_changes = {};

			if (dirty & /*$$scope*/ 1) {
				expansionpanel2_changes.$$scope = { dirty, ctx };
			}

			expansionpanel2.$set(expansionpanel2_changes);
			const expansionpanel3_changes = {};

			if (dirty & /*$$scope*/ 1) {
				expansionpanel3_changes.$$scope = { dirty, ctx };
			}

			expansionpanel3.$set(expansionpanel3_changes);
			const expansionpanel4_changes = {};

			if (dirty & /*$$scope*/ 1) {
				expansionpanel4_changes.$$scope = { dirty, ctx };
			}

			expansionpanel4.$set(expansionpanel4_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(expansionpanel0.$$.fragment, local);
			transition_in(expansionpanel1.$$.fragment, local);
			transition_in(expansionpanel2.$$.fragment, local);
			transition_in(expansionpanel3.$$.fragment, local);
			transition_in(expansionpanel4.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(expansionpanel0.$$.fragment, local);
			transition_out(expansionpanel1.$$.fragment, local);
			transition_out(expansionpanel2.$$.fragment, local);
			transition_out(expansionpanel3.$$.fragment, local);
			transition_out(expansionpanel4.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(expansionpanel0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(expansionpanel1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(expansionpanel2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(expansionpanel3, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(expansionpanel4, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(16:12) <ExpansionPanels>",
		ctx
	});

	return block;
}

// (10:0) <MaterialApp>
function create_default_slot(ctx) {
	let header;
	let t0;
	let div;
	let br0;
	let t1;
	let h1;
	let t3;
	let br1;
	let t4;
	let expansionpanels;
	let current;
	header = new Header({ $$inline: true });

	expansionpanels = new ExpansionPanels({
			props: {
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(header.$$.fragment);
			t0 = space();
			div = element("div");
			br0 = element("br");
			t1 = space();
			h1 = element("h1");
			h1.textContent = "FAQ";
			t3 = space();
			br1 = element("br");
			t4 = space();
			create_component(expansionpanels.$$.fragment);
			add_location(br0, file, 12, 12, 273);
			set_style(h1, "text-align", "center");
			add_location(h1, file, 13, 12, 291);
			add_location(br1, file, 14, 12, 344);
			attr_dev(div, "class", "container");
			add_location(div, file, 11, 8, 236);
		},
		m: function mount(target, anchor) {
			mount_component(header, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);
			append_dev(div, br0);
			append_dev(div, t1);
			append_dev(div, h1);
			append_dev(div, t3);
			append_dev(div, br1);
			append_dev(div, t4);
			mount_component(expansionpanels, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const expansionpanels_changes = {};

			if (dirty & /*$$scope*/ 1) {
				expansionpanels_changes.$$scope = { dirty, ctx };
			}

			expansionpanels.$set(expansionpanels_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header.$$.fragment, local);
			transition_in(expansionpanels.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header.$$.fragment, local);
			transition_out(expansionpanels.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(header, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			destroy_component(expansionpanels);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(10:0) <MaterialApp>",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let materialapp;
	let current;

	materialapp = new MaterialApp({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(materialapp.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(materialapp, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const materialapp_changes = {};

			if (dirty & /*$$scope*/ 1) {
				materialapp_changes.$$scope = { dirty, ctx };
			}

			materialapp.$set(materialapp_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(materialapp.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(materialapp.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(materialapp, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Faq', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Faq> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		MaterialApp,
		ExpansionPanel,
		ExpansionPanels,
		Header
	});

	return [];
}

class Faq extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Faq",
			options,
			id: create_fragment.name
		});
	}
}

export { Faq as default };
//# sourceMappingURL=faq.js.map
